#+title: My Emacs Configuration
#+options: ^:{} html-postamble:nil
#+property: header-args :mkdirp yes :tangle yes :tangle-mode: #o444 :results silent :noweb yes
#+archive: archives/%s::datetree/
#+startup: indent
* An Explanation
This is a literate configuration for =Emacs=.
Tangling this file creates an Elisp file, =~/.emacs.d/lisp/init.el=.
* Bootstrapping
** early-init
:PROPERTIES:
:header-args: :tangle-mode o444 :results silent :tangle ~/.emacs.d/early-init.el
:END:
Emacs 27.0 introduced an early-init file. It allows customization before package and UI initialization.

#+begin_src emacs-lisp :lexical t
    ;;; early-init.el --- Emacs pre package.el & GUI configuration -*- lexical-binding: t; -*-
    ;;; Code:
(setq package-enable-at-startup nil)
(setq inhibit-default-init nil)

(setq native-comp-async-report-warnings-errors nil)

(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))

(defun +reset-init-values ()
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-percentage 0.1
           gc-cons-threshold 16777216)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(setq server-client-instructions nil)
(setq frame-inhibit-implied-resize t)

(advice-add #'x-apply-session-resources :override #'ignore)
(setq desktop-restore-forces-onscreen nil)


(setq ring-bell-function #'ignore
      inhibit-startup-screen t
      inhibit-startup-message t)

(provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* Init File
** lexical binding
The following line turns on lexical binding for performance reasons.
#+begin_src emacs-lisp :lexical t
;; -*- lexical-binding: t; -*-
#+end_src

** profiling
This function displays how long Emacs took to start.
It's a rough way of knowing when/if I need to optimize my init file.
#+begin_src emacs-lisp :lexical t :tangle yes
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (message "Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract (current-time) before-init-time)))
                     gcs-done)))

;; (profiler-start 'cpu+mem)
;; (add-hook 'elpaca-after-init-hook (lambda () (profiler-stop) (profiler-report)))
#+end_src

ELP is useful for seeing which functions in a package are "hot".
#+begin_src emacs-lisp :var file="elpaca" :lexical t :tangle no
(require 'elp)
(with-eval-after-load file
  (elp-instrument-package file))
(add-hook 'elpaca-after-init-hook
          (lambda () (elp-results) (elp-restore-package (intern file))))
#+end_src

** elpaca and preloads
*** installer
#+begin_src emacs-lisp :lexical t
(defvar elpaca-installer-version 0.7)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                 ,@(when-let ((depth (plist-get order :depth)))
                                                     (list (format "--depth=%d" depth) "--no-single-branch"))
                                                 ,(plist-get order :repo) ,repo))))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

*** use package 

#+begin_src emacs-lisp :lexical t
(defmacro use-feature (name &rest args)
  "Like `use-package' but accounting for asynchronous installation.
    NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))

(elpaca elpaca-use-package
  (require 'elpaca-use-package)
  (elpaca-use-package-mode)
  (setq elpaca-use-package-by-default t))

(elpaca-wait)
#+end_src

*** dependencies
**** turn off unless needed
#+begin_src emacs-lisp :lexical t :tangle no

(setq custom-delayed-init-variables '())
(unload-feature 'eldoc t)
(use-package eldoc
  :demand t
  :config
  (global-eldoc-mode))
(elpaca-wait)

(setq custom-delayed-init-variables '())
(unload-feature 'seq t)
(use-package seq
  :demand t
  )
(elpaca-wait)
#+end_src
**** always on

#+begin_src emacs-lisp :lexical t
(use-package transient
  :defer t
  )
(use-package git-commit
  :defer t
  )
(use-package delight
  :defer t)
#+end_src

** my settings and my defs
*** displays
#+begin_src emacs-lisp :lexical t
(global-display-line-numbers-mode t)
(show-paren-mode 1)

(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)

(setq font-lock-maximum-decoration 2)

#+end_src

*** global keys

#+begin_src emacs-lisp :lexical t

(keymap-global-set "H-r" 'revert-buffer)
(keymap-global-set "H-l" 'scroll-lock-mode)
(keymap-global-set "C-x e" 'eshell)
(keymap-global-set "C-x C-;" 'comment-line)
(keymap-global-set "C-H-<up>" 'scroll-other-window-down)
(keymap-global-set "C-H-<down>" 'scroll-other-window)

#+end_src

*** misc.

#+begin_src emacs-lisp :lexical t
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)

(setq mark-ring-max 4)
(setq global-mark-ring-max 4)

(setq initial-buffer-choice t) ;;*scratch*

(setq python-indent-offset 4)
(setq python-indent-guess-indent-offset nil)

(which-key-mode)
#+end_src

*** mouse 
#+begin_src emacs-lisp :lexical t
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+end_src
*** my focus connections

#+begin_src emacs-lisp :lexical t

(defun connect-focusvq-home ()
  (interactive)
  (dired "/scp:sfigueroa@dev:~"))

(setq sql-connection-alist
      '(
        (mysql-fds (sql-product 'mysql)
                   (sql-port 0)
                   (sql-server "db.internal.focusvq.com")
                   (sql-user "fds")
                   (sql-password "WnJSuqmND9i0ePYw")
                   (sql-database "fds"))

        (mysql-elcano (sql-product 'mysql)
                      (sql-port 0)
                      (sql-server "db.internal.focusvq.com")
                      (sql-user "fds")
                      (sql-password "WnJSuqmND9i0ePYw")
                      (sql-database "elcano"))
        )
      )

(keymap-global-set "H-c h" 'connect-focusvq-home)

#+end_src

*** my gc

#+begin_src emacs-lisp :lexical t

(defun my-minibuffer-setup-hook ()
  "Set high gc when minibuffer is open."
  (setq gc-cons-threshold (* 256 1024 1024))
  (setq gc-cons-percentage 1))

(defun my-minibuffer-exit-hook ()
  "Set low GC when minibuffer exits."
  (setq gc-cons-threshold 16777216)
  (setq gc-cons-percentage 0.1))

(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook 'my-minibuffer-exit-hook)
#+end_src

*** recolor ansi
#+begin_src emacs-lisp :lexical t

(defun ansi-color-on-buffer ()
  "..."
  (interactive)

  (replace-string-in-region "[43m" "[45m" (point-min) (point-max) ) ;; replace yellow highlights
  (replace-string-in-region ";43m" ";45m" (point-min) (point-max) )
  (replace-string-in-region "[34m" "[33m" (point-min) (point-max) ) ;; replace blue text
  (replace-string-in-region ";34m" ";33m" (point-min) (point-max) )
  (ansi-color-apply-on-region (point-min) (point-max)))

#+end_src

*** set region writable
This is for when I accidentally make a column in org mode
#+begin_src emacs-lisp :lexical t

(defun set-region-writeable (begin end)
  "Removes the read-only text property from the marked region."
  ;; See http://stackoverflow.com/questions/7410125
  (interactive "r")
  (let ((modified (buffer-modified-p))
        (inhibit-read-only t))
    (remove-text-properties begin end '(read-only t))
    (set-buffer-modified-p modified)))

#+end_src

*** theme and font
#+begin_src emacs-lisp :lexical t
;; (setq custom-theme-directory "~/.emacs.d/themes/")
;; (add-to-list 'load-path custom-theme-directory)
;; (load-theme 'base16-chalk t)
(use-package color-theme-sanityinc-tomorrow
  ;;  :defer t
  :init
  (setq custom-safe-themes t)   ; Treat all themes as safe
  :config
  (global-hl-line-mode 1)
  (set-face-attribute 'hl-line nil :inherit nil :background "gray6")
 
  (add-to-list 'default-frame-alist
               '(font . "Hack-12")) 
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (color-theme-sanityinc-tomorrow-bright)

  (set-face-attribute 'tab-line nil :height 150 )
  (set-face-attribute 'tab-line-highlight nil :background "white")
  (set-face-attribute 'tab-line-tab nil :foreground "#c397d8")
  (set-face-attribute 'tab-line-tab-current nil :weight 'bold :box (list :line-width -2 :color "#c397d8") :background "gray20" :foreground "#c397d8")
  (set-face-attribute 'tab-line-tab-inactive nil :background "#c397d8")

  )
#+end_src
*** Mac os use meta
#+begin_src emacs-lisp :lexical t

;; :defer t
;; :hook after-init-hook
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :init
  (setq mac-option-modifier 'hyper ;; for emacs-mac
        mac-command-modifier 'meta
        mac-right-option-modifier 'super)
  (setq ns-command-modifier 'meta ;; for emacs-plus
        ns-option-modifier 'hyper
        ns-right-option-modifier 'super
        )
  ;;  (setq exec-path-from-shell-debug t)
  :config
  (setq exec-path-from-shell-arguments (list "-l")) ;; (list "-l" "-i")
  (exec-path-from-shell-initialize)
  ;; :defer t
  )
#+end_src

*** tramp
#+begin_src emacs-lisp :lexical t
(use-feature tramp 
  :config
  ;; (when (string-equal emacs-version "29.2")
  ;;   (with-current-buffer
  ;;       (url-retrieve-synchronously
  ;;        "https://git.savannah.gnu.org/cgit/emacs.git/plain/lisp/emacs-lisp/loaddefs-gen.el?h=emacs-29")
  ;;     (goto-char (point-min))
  ;;     (while (looking-at "^.+$") (forward-line))
  ;;     (eval-region (point) (point-max))))
  (setq shell-file-name "/bin/bash") 
  (setq tramp-default-method "scp")
  (with-eval-after-load 'tramp (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
  (with-eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
  )

(use-package counsel-tramp
  :bind* ("C-c f" . counsel-tramp)
  :defer t
  :init
  (setq counsel-tramp-custom-connections '(/scp:sfigueroa@dev:~/ /scp:sfigueroa@dev:~/elcano/ ))
  (setq make-backup-files nil)
  (setq create-lockfiles nil) 
  )
#+end_src

*** recentf
#+BEGIN_SRC emacs-lisp :lexical t
(use-feature recentf
  :after tramp
  :init
  (setq recentf-auto-cleanup nil) ;; disable before we start recentf!
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 25)
  
  :config
  (recentf-mode 1)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  (add-to-list 'recentf-exclude "\\.png\\'")
  (recentf-cleanup)
  :defer t
  )
#+END_SRC

** Install Packages
*** ace
**** window

# TODO make a toggle for zoom and balance
#+begin_src emacs-lisp :lexical t

(use-package ace-window
  :delight
  :bind* (
          ("H-SPC" . ace-window)
          ("H-<left>" . shrink-window-horizontally)
          ("H-<right>" . enlarge-window-horizontally)
          ("H-<up>" . enlarge-window)
          ("H-<down>" . shrink-window)
          ("H-z" . seth-toggle-zoom-balance)
          )
  :defer t
  :custom
  (aw-dispatch-always t)
  :init
  (require 'zoom)
  (setq seth-is-zoom 1)
  (defun seth-toggle-zoom-balance ()
    (interactive)
    (setq seth-is-zoom (* -1 seth-is-zoom))
    (zoom-mode seth-is-zoom)
    )
  (zoom-mode seth-is-zoom)
  (defvar aw-dispatch-alist
    '((?d aw-delete-window "Delete Window")
      (?s aw-swap-window "Swap Windows")
      (?m aw-move-window "Move Window")
      (?b aw-switch-buffer-in-window "Select Buffer")
      (?n aw-flip-window)
      (?B aw-switch-buffer-other-window "Switch Buffer Other Window")
      (?c aw-split-window-fair "Split Fair Window")
      (?h aw-split-window-vert "Split Vert Window")
      (?v aw-split-window-horz "Split Horz Window")
      (?o delete-other-windows "Delete Other Windows")
      (?? aw-show-dispatch-help))
    "List of actions for `aw-dispatch-default'.")
  )
#+end_src

**** jump mode
#+begin_src emacs-lisp :lexical t
(use-package ace-jump-mode
  :delight
  :bind* ("H-j" . ace-jump-mode)
  :defer t
  )
#+end_src

**** multiple cursors
#+begin_src emacs-lisp :lexical t
(use-package ace-mc
  :delight
  :bind* ("H-;" . ace-mc-add-multiple-cursors)
  :defer t
  )
#+end_src

*** auto-tangle-mode

#+begin_src emacs-lisp :lexical t

(use-package auto-tangle-mode
  :delight
  :ensure (auto-tangle-mode
           :host github
           :repo "progfolio/auto-tangle-mode.el"
           :local-repo "auto-tangle-mode")
  :defer t 
  ;; :hook org-mode
  ;; :config
  ;; (auto-tangle-mode)
  ;; (add-hook 'auto-tangle-after-tangle-hook (lambda ()
  ;;                                            (let ((elpaca-log-functions nil))
  ;;                                              (load-file "~/.emacs.d/init.el")
  ;;                                              (elpaca-process-queues))))
  )

#+end_src

*** bufler

#+begin_src emacs-lisp :lexical t
(use-package bufler
  :defer t
  :bind* (
          ("C-x C-b" . bufler-sidebar)
          )
  :delight
  :config
  (setf bufler-groups
        (bufler-defgroups
          (group
           ;; Subgroup collecting all named workspaces.
           (auto-workspace))
          (group
           ;; images
           (mode-match "*images*" (rx bos "image-mode"))
           )
          (group
           ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
           (group-or "*Help/Info*"
                     (mode-match "*Help*" (rx bos "help-"))
                     (mode-match "*Info*" (rx bos "info-"))))
          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not
           ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
           ;; through to other groups, so they end up grouped with their project buffers).
           (group-and "*Special*"
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                             buffer)
                                    (funcall (mode-match "Dired" (rx bos "dired"))
                                             buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*")))
           (group
            ;; Subgroup collecting these "special special" buffers
            ;; separately for convenience.
            (name-match "**Special**"
                        (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))
           (group
            ;; Subgroup collecting all other Magit buffers, grouped by directory.
            (mode-match "*Magit* (non-status)" (rx bos (or "magit" "forge") "-"))
            (auto-directory))
           ;; Subgroup for Helm buffers.
           (mode-match "*Helm*" (rx bos "helm-"))
           ;; Remaining special buffers are grouped automatically by mode.
           (auto-mode))
          ;; All buffers under "~/.emacs.d" (or wherever it is).
          (dir user-emacs-directory)
          (group
           ;; Subgroup collecting buffers in `org-directory' (or "~/org" if
           ;; `org-directory' is not yet defined).
           (dir (if (bound-and-true-p org-directory)
                    org-directory
                  "~/org"))
           (group
            ;; Subgroup collecting indirect Org buffers, grouping them by file.
            ;; This is very useful when used with `org-tree-to-indirect-buffer'.
            (auto-indirect)
            (auto-file))
           ;; Group remaining buffers by whether they're file backed, then by mode.
           (group-not "*special*" (auto-file))
           (auto-mode))
          (group
           ;; Subgroup collecting buffers in a projectile project.
           (auto-projectile))
          (group
           ;; Subgroup collecting buffers in a version-control project,
           ;; grouping them by directory.
           (auto-project))
          ;; Group remaining buffers by directory, then major mode.
          (group
           ;; magit
           (mode-match "*magit-leftovers*" (rx bos "magit-process-mode"))
           )

          (group
           ;; logs and out stuff
           (mode-match "*Fundamental*" (rx bos "fundamental-mode"))
           )
          
          (auto-directory)
          (auto-mode))
        )
  )

#+end_src

*** buffer-expose
#+begin_src emacs-lisp :lexical t

(use-package buffer-expose
  :delight
  :config
  (setcdr buffer-expose-mode-map nil)

  ;; :defer t
  :bind* (
          ("H-b e" . buffer-expose)
          ("H-b b" . buffer-expose-no-stars)
          ("H-b c" . buffer-expose-current-mode)
          ("H-b s" . buffer-expose-major-mode)
          ("H-b d" . buffer-expose-dired-buffers)
          ("H-b *" . buffer-expose-stars)
          )
  :config
  (buffer-expose-mode 1)  
  )

#+end_src

*** company
#+begin_src emacs-lisp :lexical t

(use-package company
  :delight
  :defer t
  :bind* ("C-<tab>" . company-other-backend)
  :hook ((prog-mode org-mode) . company-mode)
  :custom-face
  (company-preview                      ((t (:background "gray10" :foreground "#c397d8" :extend t))))
  (company-preview-common               ((t (:inherit company-preview :foreground "#c397d8" :extend t))))
  (company-preview-search               ((t (:inherit company-preview :foreground "#7aa6da" :extend t))))
  (company-tooltip                      ((t (:background "gray10" :foreground "#eaeaea" :extend t))))
  (company-tooltip-selection            ((t (:background "gray10" :foreground "#969896" :extend t))))
  (company-tooltip-common               ((t (:inherit company-tooltip :foreground "#c397d8" :extend t))))
  (company-tooltip-common-selection     ((t (:inherit company-tooltip-selection :foreground "#c397d8" :extend t))))
  (company-tooltip-search               ((t (:inherit company-tooltip :foreground "#7aa6da" :extend t))))
  (company-tooltip-annotation           ((t (:inherit company-tooltip :foreground "#70c0b1" :extend t))))
  (company-tooltip-annotation-selection ((t (:inherit company-tooltip-selection :foreground "#70c0b1" :extend t))))
  (company-echo-common                  ((t (:inherit company-echo :foreground "#c397d8" :extend t))))
  :init
  (setq company-tooltip-align-annotations t)
  (setq company-idle-delay nil)
  (setq company-tooltip-idle-delay 1)
  (setq company-minimum-prefix-length 0)
  (setq company-require-match 'never)
  (setq company-show-numbers t)
  (setq company-tooltip-limit 20)
  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case t)
  (setq company-dabbrev-code-ignore-case t)
  (setq company-dabbrev-code-everywhere t)
  (setq company-etags-ignore-case t)
  )

#+end_src

*** counsel

#+begin_src emacs-lisp :lexical t
(use-package counsel
  :defer t
  :bind* (
         ("M-x" . counsel-M-x)
         ("C-x b" . ivy-switch-buffer)
;;         ("C-x C-b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         ("C-x M-f" . counsel-file-jump)
         ("C-x C-d" . counsel-dired)
         ("C-x f" . counsel-recentf)
         ("C-x C-a" . counsel-ag)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)
         ("C-h i" . counsel-info-lookup-symbol) 
         )
  :delight
  :config
  (counsel-mode)
  )
#+end_src

*** csv
#+begin_src emacs-lisp :lexical t 
  (use-package csv-mode
    :mode "\\.csv\\'"
    )
#+end_src

*** d20
#+begin_src emacs-lisp :lexical t
(use-package org-d20
  :delight
  :defer t
  :config
  (require 's)
  (require 'seq)
  (require 'dash)
  (require 'cl-lib)
  (require 'subr-x)
  (require 'org-table)
  
  (pretty-hydra-define d20-hydra (:color blue :hint nil)
    (
     "Initiative"
     (
      ("i" org-d20-initiative-add "add initiative" :exit nil)
      ("n" org-d20-initiative-dwim "next initiative" :exit nil)
      ("p" org-d20-initiative-back "prev initiative" :exit nil)
      )
     
     "Roll"
     (
      ("r" org-d20-roll "roll" :exit nil)
      ("P" org-d20-roll-at-point "roll at point" :exit nil)
      ("a" org-d20-d20 "Advantage/Disadvatage" :exit nil)
      )
     
     "Edit"
     (
      ("d" org-d20-damage "damage" :exit nil)
      ("t" org-table-align "align" :exit nil)
      ("q" nil "quit")
      )
     )
    )

  (defun org-d20-initiative ()
    "Generate an Org-mode table with initiative order and monster/NPC HP."
    (interactive "*")
    (let ((rows))
      (let (name-input init-input ac-input hd-input num-input (monster 1))
        (cl-loop
         do (setq name-input (read-string "Monster/NPC name (blank when done): "))
         (when (> (length name-input) 0)
           (setq init-input (read-string (concat name-input "'s init modifier: "))
                 ac-input (read-string (concat name-input "'s Armor Class: "))
                 hd-input (read-string (concat name-input "'s hit points: "))
                 num-input
                 (cdr (org-d20--roll
                       (read-string (concat "How many " name-input "? ")))))
           ;; In 5e, all monsters of the same kind have the same
           ;; initiative
           (let ((init (int-to-string
                        (org-d20--d20-plus (string-to-number init-input))))
                 (monsters-left num-input))
             (while (>= monsters-left 1)
               (let (
                     (hp (int-to-string (cdr (org-d20--roll hd-input))))
                     (ac (int-to-string (cdr (org-d20--roll ac-input))))
                     )
                 (push (list
                        "" (concat name-input
                                   " "
                                   (org-d20--monster-number monster))
                        (org-d20--num-to-term init-input) init ac hp "0")
                       rows))
               (setq monsters-left (1- monsters-left)
                     monster (1+ monster)))))
         (unless org-d20-continue-monster-numbering (setq monster 1))
         while (-all? (lambda (x) (> (length x) 0))
                      (list name-input init-input ac-input hd-input))))
      (dolist (pc org-d20-party)
        (let ((init (read-string (concat (car pc) "'s initiative roll: "))))
          (push (list "" (car pc) (org-d20--num-to-term (cdr pc)) init "-" "-" "-")
                rows)))
      ;; We prepended each new item to the list, so reverse before
      ;; printing.  This ensures that the numbering/lettering of
      ;; monsters on the same initiative count is ascending
      (setq rows (seq-reverse rows))
      (insert
       "Round of combat: 1\n|Turn|Creature|Mod|Init|AC|HP|Damage|Status|\n|-\n")
      (dolist (row rows)
        (dolist (cell row)
          (insert "|" cell))
        (insert "|\n"))
      (delete-char -1)
      (org-table-goto-column 4)
      (org-table-sort-lines nil ?N)
      (org-table-goto-line 2)
      (org-table-goto-column 1)
      (insert ">>>>")                     ; four chars in 'Turn'
      (org-table-align)))


  (defun org-d20-initiative-back ()
    "Go back an turn on the turn tracker in an initiative table."
    (interactive "*")
    (when (org-at-table-p)
      (cl-loop
       do (let* ((back (search-backward ">>>>" (org-table-begin) t))
                 (forward (search-forward ">>>>" (org-table-end) t))
                 (cur (if back back forward)))
            (goto-char cur)
            (skip-chars-backward ">")
            (delete-char 4)
            (if (not 
                 (eq 2 (org-table-current-line)))
                (progn
                  (forward-line -1)
                  (org-table-next-field)
                  (insert ">>>>"))
              (save-excursion
                (search-backward "Round of combat:")
                (search-forward-regexp "[0-9]+")
                (skip-chars-backward "0-9")
                (replace-match
                 (int-to-string (1- (string-to-number (match-string 0))))))
              (goto-char (org-table-end))
              (backward-char)
              (org-table-goto-column 1)
              (insert ">>>>")))
       while (save-excursion
               (org-table-goto-column 2)
               (looking-at "~"))))
    (org-table-align))

  (defun org-d20-initiative-advance ()
    "Advance the turn tracker in an initiative table."
    (interactive "*")
    (when (org-at-table-p)
      (cl-loop
       do (let* ((back (search-backward ">>>>" (org-table-begin) t))
                 (forward (search-forward ">>>>" (org-table-end) t))
                 (cur (if back back forward)))
            (goto-char cur)
            (skip-chars-backward ">")
            (delete-char 4)
            (if (save-excursion
                  (org-table-goto-line (1+ (org-table-current-line))))
                (progn
                  (forward-line 1)
                  (org-table-next-field)
                  (insert ">>>>"))
              (save-excursion
                (search-backward "Round of combat:")
                (search-forward-regexp "[0-9]+")
                (skip-chars-backward "0-9")
                (replace-match
                 (int-to-string (1+ (string-to-number (match-string 0))))))
              (org-table-goto-line 2)
              (insert ">>>>")))
       while (save-excursion
               (org-table-goto-column 2)
               (looking-at "~"))))
    (org-table-align))

  (defun org-d20-damage (dmg)
    "Apply DMG poitns of damage to the monster/NPC in the table row at point."
    (interactive "*nDamage dealt: ")
    (when (org-at-table-p)
      (org-table-goto-column 7)
      (skip-chars-forward " ")
      (when (looking-at "[0-9]+")
        (let ((total-damage (+ dmg (string-to-number (match-string 0)))))
          (replace-match (int-to-string total-damage))
          (save-excursion
            (org-table-goto-column 6)
            (skip-chars-forward " ")
            (when (looking-at "[0-9]+")
              (let ((max-hp (string-to-number (match-string 0))))
                (if (>= total-damage max-hp)
                    (progn
                      (org-table-goto-column 2)
                      (insert "~")
                      (org-d20--org-table-end-of-current-cell-content)
                      (insert "~"))
                  (when (>= total-damage (/ max-hp 2))
                    (org-table-goto-column 8)
                    (org-d20--org-table-end-of-current-cell-content)
                    (unless (looking-back "bloodied" nil)
                      (unless (looking-back "|" nil)
                        (insert "; "))
                      (insert "bloodied")))))))))
      (org-table-align)))

  (defun org-d20-initiative-dwim ()
    "Start a new combat or advance the turn tracker, based on point."
    (interactive "*")
    (if (org-at-table-p)
        (org-d20-initiative-advance)
      (org-d20-initiative)))


  (defun org-d20-initiative-add ()
    "Add a monster to an existing combat."
    (interactive "*" org-mode)
    (if (org-at-table-p)
        (let* ((name-input (read-string "Monster/NPC name: "))
               (init-input (read-number (concat name-input "'s init modifier: ")))
               (ac-input (read-number (concat name-input "'s Armor Class: ")))
               (hd-input (read-string (concat name-input "'s hit points: ")))
               (num-input (read-string (concat "How many " name-input "? "))))
          (org-d20--initiative-add-records name-input init-input ac-input hd-input num-input))
      (org-d20-initiative)))




  (defun org-d20--initiative-add-records (name init-mod ac hd num)
    (let ((monster 1))
      ;; First, if we need to, try to count the number of monsters.
      ;; We can only use a crude heuristic here because we don't
      ;; know what kind of things the user might have added to the
      ;; table
      (when org-d20-continue-monster-numbering
        (save-excursion
          (org-table-goto-line 1)
          (while (org-table-goto-line (1+ (org-table-current-line)))
            (org-table-goto-column 2)
            (when (looking-at "[^|]+ \\([A-Z]\\|[0-9]+\\)~? *|")
              (setq monster (1+ monster))))))
      (save-excursion
        ;; Ensure we're not on header row (following won't go past end
        ;; of table)
        (org-table-goto-line (1+ (org-table-current-line)))
        (org-table-goto-line (1+ (org-table-current-line)))
        (let ((init (int-to-string (org-d20--d20-plus init-mod)))
              (monsters-left (cdr (org-d20--roll num))))
          (while (>= monsters-left 1)
            ;; Open a new row and then immediately move it downwards
            ;; to ensure that the monsters on the same initiative
            ;; count are numbered/lettered in ascending order
            (org-table-insert-row)
            (org-table-move-row)
            (org-table-next-field)
            (insert name)
            (insert " ")
            (insert (org-d20--monster-number monster))
            (org-table-next-field)
            (insert (org-d20--num-to-term init-mod))
            (org-table-next-field)
            (insert init)
            (org-table-next-field)
            (insert (int-to-string (cdr (org-d20--roll ac))))
            (org-table-next-field)
            (insert (int-to-string (cdr (org-d20--roll hd))))
            (org-table-next-field)
            (insert "0")
            (setq monsters-left (1- monsters-left)
                  monster (1+ monster))))
        (org-table-goto-column 4)
        (org-table-sort-lines nil ?N)
        (org-table-align))))


  ;; (define-key org-mode-map (kbd "H-h d") 'd20-hydra/body)

  
  :bind (
         :map org-d20-mode-map
         ("H-h d" . 'd20-hydra/body)
         ("H-d i". 'org-d20-initiative-add)
         ("H-d n". 'org-d20-initiative-dwim)
         ("H-d p". 'org-d20-initiative-back)
         ("H-d d". 'org-d20-damage)
         ("H-d r". 'org-d20-roll)
         ("H-d e". 'org-d20-roll-at-point)
         ("H-d a". 'org-d20-d20)
         )
  
  )
#+end_src

*** dashboard

#+begin_src emacs-lisp :lexical t :tangle no

(use-package dashboard
  :custom
  (dashboard-banner-logo-title "It's Emacs time!")
  (dashboard-startup-banner 'logo)
  (dashboard-items '((recents  . 15)
                     (projects . 5)
                     ))
  :config
  ;; (add-hook 'elpaca-after-init-hook #'dashboard-insert-startupify-lists)
  ;; (add-hook 'elpaca-after-init-hook #'dashboard-initialize)
  (dashboard-setup-startup-hook)
  )

;; Value can be
;; 'official which displays the official emacs logo
;; 'logo which displays an alternative emacs logo
;; 1, 2 or 3 which displays one of the text banners


#+end_src

*** dired

#+begin_src emacs-lisp :lexical t
  (use-package all-the-icons
    :defer t
    :if (display-graphic-p)
    )

  (use-package all-the-icons-dired
    :defer t
    :delight
    :hook (dired-mode . all-the-icons-dired-mode)
    :custom
    (all-the-icons-dired-monochrome nil)
    )

  ;; (use-package dired-subtree
  ;;   :delight
  ;;   :bind (
  ;;          :map dired-mode-map
  ;;          ("H-r" . dired-subtree-remove)
  ;;          ("<tab>" . dired-subtree-toggle)
  ;;          ("H-p" . dired-subtree-up)
  ;;          ("H-n" . dired-subtree-down)
  ;;          ("H-<up>" . dired-subtree-beginning)
  ;;          ("H-<down>" . dired-subtree-end)
  ;;          ("H-m" . dired-subtree-mark-subtree)
  ;;          ("H-u" . dired-subtree-unmark-subtree)           
  ;;          )
  ;;   :defer t
  ;;   )

  (use-package dired-filter
    :custom
    (dired-listing-switches "-alogh")
    :defer t
    :hook (dired-mode)
    )

  (use-feature dired
    ;; :bind* ("C-x d" . seth/dired-side-vc)
    :defer t
    :delight
    :custom-face
    (dired-directory ((t (:foreground "#97c8f7" :extend t)))) 
    (dired-marked    ((t (:foreground "#e78c45" :extend t)))) 
    :config
    ;; (require 'dired-subtree)
    (when (string= system-type "darwin")       
      (setq dired-use-ls-dired nil))
    ;; (defun seth/dired-side--vc (directory)
    ;;   "Open the root directory of the current version-controlled repository or th present working directory with `dired' and bespoke window parameters."
    ;;   (let* (
    ;;          (backend (vc-responsible-backend directory t))
    ;;          (dir (if (eq backend nil)
    ;;                   directory
    ;;                 (expand-file-name (vc-call-backend backend 'root directory))))
    ;;          (dired_dir (dired-noselect dir))
    ;;          (path-list (split-string (first (last (split-string directory dir))) "/"))
    ;;          )
    ;;     (display-buffer-in-side-window
    ;;      dired_dir `((side . left)
    ;;                  (slot . 0)
    ;;                  (window-width . 0.3)
    ;;                  (window-parameters) . ((no-other-window . t)
    ;;                                         (no-delete-other-windows . t)
    ;;                                         (mode-line-format . (" " "%b"))
    ;;                                         )
    ;;                  )
    ;;      )
    ;;     (with-current-buffer dired_dir
    ;;       (setq window-size-fixed 'width)
    ;;       (switch-to-buffer-other-frame dired_dir)
    ;;       (revert-buffer)
    ;;       (dired-hide-details-mode)
    ;;       (goto-char 0)
    ;;       (cl-loop for p in path-list do
    ;;                (goto-char (search-forward p))
    ;;                (dired-subtree-insert)
    ;;                )
    ;;       )
    ;;     )
    ;;   )
    ;; (defun seth/dired-side-vc (&optional initial-input)
    ;;   "Open the root directory of the current version-controlled repository or th present working directory with `dired' and bespoke window parameters."
    ;;   (interactive) 
    ;;   (ivy-read "Dired: " #'read-file-name-internal
    ;;             :matcher #'counsel--find-file-matcher
    ;;             :initial-input initial-input
    ;;             :action (lambda (d) (seth/dired-side--vc (expand-file-name d)))
    ;;             :preselect (counsel--preselect-file)
    ;;             :require-match 'confirm-after-completion
    ;;             :history 'file-name-history
    ;;             :keymap counsel-find-file-map
    ;;             :caller 'counsel-dired)
    ;;   )    
    )


#+end_src

*** drag stuff

#+begin_src emacs-lisp :lexical t
(use-package drag-stuff
  :delight
  :defer t
  :config
  (drag-stuff-global-mode 1)
  :bind* (
         ("C-M-<down>" . drag-stuff-down)
         ("C-M-<up>" . drag-stuff-up)  
         )
  )
#+end_src

*** dumb jump

#+begin_src emacs-lisp :lexical t
(use-package dumb-jump
  :delight
  :custom
  (xref-show-definitions-function #'xref-show-definitions-completing-read)
  :init (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  :config
  (add-to-list 'dumb-jump-language-file-exts '(:language "python" :ext "org" :agtype "python" :rgtype "py"))
  (defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("j" dumb-jump-go "Jump")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back"))
  :bind ("H-h ." . dumb-jump-hydra/body)
  )

#+end_src

*** embark
#+begin_src emacs-lisp :lexical t
(use-package embark
  :ensure t
  :defer t
  :bind*
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)  ;; alternative for `describe-bindings'
   ) 

  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

#+end_src

*** flycheck
#+begin_src emacs-lisp :lexical t

(use-package flycheck
  :defer t)  

#+end_src

*** google
#+begin_src emacs-lisp :lexical t
;; google-this
(use-package google-this
  :delight
  :config
  (google-this-mode 1))  
#+end_src

*** highlight indend guides

#+begin_src emacs-lisp :lexical t
(use-package indent-bars

  :ensure (indent-bars :type git :host github :repo "jdtsmith/indent-bars")
  :defer t
  :hook ((prog-mode org-mode) . indent-bars-mode)
  :config
  (setq
   indent-bars-prefer-character t
   indent-bars-color '(highlight :face-bg t :blend 0.5)
;;   indent-bars-pattern ". . . . . . . . ." ; play with the number of dots for your usual font size
   indent-bars-width-frac 0.3
   indent-bars-pad-frac 0.1
   indent-bars-display-on-blank-lines t
   indent-tabs-mode nil)

  ;; (setq
  ;;  indent-bars-color '(highlight :face-bg t :blend 0.1)
  ;;  indent-bars-pattern ". . . . . . . . ."
  ;;  indent-bars-width-frac 0.1
  ;;  indent-bars-pad-frac 0.1
  ;;  indent-bars-zigzag nil
  ;;  indent-bars-color-by-depth '(:regexp "outline-\\([0-9]+\\)" :blend 1) ; blend=1: blend with BG only
  ;;  indent-bars-highlight-current-depth '(:blend 1) ; pump up the BG blend on current
  ;;  indent-bars-display-on-blank-lines t)

  (setq indent-bars-treesit-support t)
  (setq indent-bars-no-descend-string t)
  (setq indent-bars-treesit-ignore-blank-lines-types '("module" "call"))
  (setq indent-bars-treesit-wrap '((python
                                    argument_list
                                    attribute
                                    assignment
                                    identifier
                                    parameters
                                    list
                                    list_comprehension
                                    dictionary
                                    dictionary_comprehension
                                    parenthesized_expression
                                    call
                                    expression_statement
                                    subscript)))
  
  ) ; or whichever modes you prefer




;; (use-package highlight-indent-guides
;; :hook (prog-mode . highlight-indent-guides-mode)
;;    :init
;;  (setq highlight-indent-guides-method 'bitmap)
;;      (setq highlight-indent-guides-responsive 'top)

;;    )
#+end_src

*** HL todo

#+begin_src emacs-lisp :lexical t
(use-package hl-todo
  :delight
  :config
  (setq hl-todo-keyword-faces
   '(("TODO" . "#E078F5")
     ("NOTE" . "#1EAFFF")
     ("HACK" . "#FF5B24")
     ("BUG"  . "#FF0000")
     ))
  (global-hl-todo-mode)
  :bind* (
         ("H-t t" . hl-todo-insert)
         ("H-t n" . hl-todo-next)
         ("H-t p" . hl-todo-previous)
         )
  )

#+end_src

*** hydra


#+begin_src emacs-lisp :lexical t

(use-package hydra
  :defer t
  :custom
  (hydra-is-helpful t)
  )
(use-package ivy-hydra
  :defer t)

(use-package pretty-hydra
  :defer t)
#+end_src

*** Ivy
#+begin_src emacs-lisp :lexical t

(use-package ivy
  :init
  (setq ivy-use-virtual-buffers t)
  (setq ivy-virtual-abbreviate 'full)
  (setq ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
  (setq ivy-height 12)
  (setq ivy-display-style 'fancy)
  (setq ivy-count-format "[%d/%d] ")
  (setq ivy-initial-inputs-alist nil)
  (setq ivy-use-selectable-prompt t)
  (setq ivy-magic-slash-non-match-action 'ivy-magic-slash-non-match-create)
  ;; default pattern ignores order.
  (setf (cdr (assoc t ivy-re-builders-alist))
	    'ivy--regex-ignore-order)
  :delight
  :defer t
  )
#+end_src

*** Iscroll
#+begin_src emacs-lisp :lexical t

(use-package iscroll
  :delight
  :defer t
  )

#+end_src

*** magit

#+begin_src emacs-lisp :lexical t

(use-package magit
  :delight
  :defer t
  :bind* ("C-x g" . magit-status)
  :config 
  (setq split-height-threshold nil)
  (setq split-width-threshold 0)
  (setq magit-completing-read-function 'ivy-completing-read)
  (setenv "GIT_ASKPASS" "git-gui--askpass")
  )
#+end_src

*** marginalia
#+begin_src emacs-lisp :lexical t
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind* ("H-a" . marginalia-cycle)
  :defer t
  ;; The :init section is always executed.
  :init
  ;; Marginalia must be activated in the :init section of use-package such that
  ;; the mode gets enabled right away. Note that this forces loading the
  ;; package.
  (marginalia-mode))

(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))
#+end_src

*** markdown mode
#+begin_src emacs-lisp :lexical t

(use-package markdown-mode
  :defer t
  )
  
#+end_src

*** Multiple cursors
#+begin_src emacs-lisp :lexical t
(use-package multiple-cursors
  :bind (         
         ("H-<return> e" . mc/edit-lines)
         ("H-<return> m" . mc/mark-more-like-this-extended)
         ("H-<return> a" . mc/mark-all-like-this)
         ("H-<return> n" . mc/insert-numbers)
         ("H-<return> l" . mc/insert-letters)
         :map mc/keymap
         ("C-;" . mc-hide-unmatched-lines-mode)
         )
  ) 

#+end_src

*** org
**** org general

#+begin_src emacs-lisp :lexical t
  (use-feature org
    :defer t
    :custom
    (enable-local-variables t)
    (org-display-remote-inline-images 'cache)
    (org-startup-folded t)
    (org-startup-indented t)
    (org-log-done t)
    (org-return-follows-link t)
    (org-confirm-babel-evaluate nil)
    :bind (
           :map org-mode-map
           ;;("C-M-<up>" . org-shiftmetaup)
           ;;("C-M-<down>" . org-shiftmetadown)
           ("s-C-l" . seth-clear-all-results)
           ("C-M-<left>" . org-shiftmetaleft)
           ("C-M-<right>" . org-shiftmetaright)
           ("C-M-S-<left>" . org-shiftcontrolleft)
           ("C-M-S-<right>" . org-shiftcontrolright)
           ("s-p" . org-babel-previous-src-block)
           ("s-n" . org-babel-next-src-block)
           ("s-l" . org-babel-remove-result)
           ("s-<tab>" . completion-at-point)
           ("s-z" . org-babel-switch-to-session)
           ) 
    :init
    (defun seth-clear-all-results ()
      "Clear all results in the buffer."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (org-babel-next-src-block)
          (forward-line -1)
          (beginning-of-line)
          (when (looking-at "#\\+LASTRUN:")
            (delete-region (pos-bol) (1- (pos-bol 2)))
            (delete-line)
            )
          (forward-line 1)
          (org-babel-remove-result))))

    (add-hook 'org-mode-hook (lambda ()
                               (setq-local seth-jupyter-execution-count 1)))
    ;; (setq seth-jupyter-execution-count 1)
    
    (setq org-src-fontify-natively t
          org-src-window-setup 'current-window ;; edit in current window
          org-src-strip-leading-and-trailing-blank-lines t
          org-src-preserve-indentation t ;; do not put two spaces on the left
          org-src-tab-acts-natively t)

    :config
    ;; (require 'scimax-jupyter)
    ;; (defun seth-org-babel-add-time-stamp-after-execute-before-src-block ()
    ;;   ;; (sleep-for 2)    
    ;;   (end-of-line)
    ;;   (save-excursion
    ;;     (search-backward "#+BEGIN_SRC" 0 t)
    ;;     (forward-line -1)
    ;;     (beginning-of-line)

    ;;     (if (looking-at "#\\+LASTRUN:")
    ;;         (delete-region (pos-bol) (1- (pos-bol 2)))
    ;;       (open-line 1)
    ;;       (next-line 1)
    ;;       )
        
    ;;     (insert (concat
    ;;              "#+LASTRUN: "
    ;;              (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time))
    ;;              " ["
    ;;              (int-to-string seth-jupyter-execution-count)
    ;;              "]"
    ;;              ))
    ;;     (setq-local seth-jupyter-execution-count (1+ seth-jupyter-execution-count))
    ;;     )
    ;;   )

    ;; (add-hook 'org-babel-after-execute-hook
    ;;           'seth-org-babel-add-time-stamp-after-execute-before-src-block)

    )

  ;; Backend for HTML Table export

  ;;(require 'ox-html)
  ;;(defun ox-mrkup-filter-bold
  ;;    (text back-end info)
  ;;  "Markup TEXT as <bold>TEXT</bold>. Ignore BACK-END and INFO."
  ;;  (format "<bold>%s</bold>" text))
  ;;
  ;;(org-export-define-derived-backend 'htmlTable 'html
  ;;  :filters-alist
  ;;  '((:filter-body . ox-mrkup-filter-body)
  ;;    ))

#+end_src

**** org modern

#+begin_src emacs-lisp :lexical t

(use-package org-modern
  :hook (org-mode)
  :defer t
  :custom-face
  (org-block   ((t (:background "gray10" :extend t))))
  (org-block-begin-line   ((t (:inherit org-block :background "#1b2419" :foreground "#876716" :extend t))))
  (org-block-end-line     ((t (:inherit org-block-begin-line :background "gray10" :foreground "#876716" :extend t))))
  (org-drawer             ((t (:inherit shadow))))
  (org-level-1            ((t (:weight bold :height 1.2 :overline nil :underline t :extend t)))) ;; Blue :foreground "#3375a8"
  (org-level-2            ((t (:weight bold :height 1.2 :overline nil :extend t)))) ;; Aqua
  (org-level-3            ((t (:weight bold :height 1.1 :overline nil :extend t)))) ;; Green
  (org-level-4            ((t (:weight bold :height 1.1 :overline nil :extend t)))) ;; Yellow
  (org-level-5            ((t (:weight bold :height 1.1 :overline nil :extend t)))) ;; Orange
  (org-level-6            ((t (:weight bold :height 1.1 :overline nil :extend t)))) ;; Red
  (org-level-7            ((t (:weight bold :height 1.1 :overline nil :extend t)))) ;; Blue
  (org-level-8            ((t (:weight bold :height 1.1 :overline nil :extend t))))

  :config
  (setq-local line-spacing 0.1)
  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
   'append)

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:-\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-todo prepend))
   'append)

  (setq
   ;; Edit settings
   org-babel-min-lines-for-block-output 1
   org-auto-align-tags nil
   org-tags-column 0
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Org styling, hide markup etc.
   org-hide-emphasis-markers t
   org-pretty-entities nil
   org-modern-fold-stars '(("▶" . "▼") ("▷" . "▽") ("▶" . "▼") ("▹" . "▿") ("▸" . "▾"))
   ;; Agenda styling
   org-agenda-tags-column 0
   org-agenda-block-separator ?─
   org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
   org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────"

   org-agenda-ndays 7
   org-deadline-warning-days 10
   org-agenda-show-all-dates t
   org-agenda-start-on-weekday nil
   org-reverse-note-order t
   org-fast-tag-selection-single-key (quote expert)
   org-log-into-drawer t
   org-image-actual-width nil
   org-export-with-drawers t
   )
  )
#+end_src

*** page-break lines
#+begin_src emacs-lisp :lexical t
  (use-package page-break-lines
    :defer t
    :delight
    :config
    (global-page-break-lines-mode)
    )

#+end_src

*** popper
#+begin_src emacs-lisp :lexical t :tangle yes

(use-package popper
  :init
  ;; (setq popper-group-function 'nil) ; projectile projects #'popper-group-by-projectile
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          help-mode
          compilation-mode
          image-mode
          ))

  ;; Match eshell, shell, term and/or vterm buffers
  (setq popper-reference-buffers
        (append popper-reference-buffers
                '("^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
                  "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
                  "^\\*term.*\\*$"   term-mode   ;term as a popup
                  "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup
                  "^\\*jupyter-repl*\\*$" jupyter-repl-mode
                  ;; ("\\*jupyter-*\\*$" . hide)
                  ;; (special-mode . hide)
                  ;; (fundamental-mode . hide)
                  ("\\*jupyter-display\\*" . hide)
                  ("\\*jupyter-traceback\\*" . hide)
                  ("\\*jupyter-output\\*" . hide)
                  ("\\*jupyter-error\\*" . hide)                  
                  )))
  (setq popper-group-function #'popper-group-by-project)
  (setq popper-display-control t)  ;This is the DEFAULT behavior
  ;; (setq popper-display-function #'display-buffer-pop-up-frame)
  
  :bind (
         ("s-;" . popper-toggle)
         ("s-C-;" . popper-cycle)
         ("s-C-:" . popper-cycle-backwards)
         ("s-M-:" . popper-kill-latest-popup)
         ("s-M-;" . popper-toggle-type)
         )
  :config
  (popper-mode)
  (popper-tab-line-mode)
  )


#+end_src

*** posframe
#+begin_src emacs-lisp :lexical t
(use-package company-posframe
  :delight
  :config
  (company-posframe-mode 1)
  :bind (
         :map company-active-map
              ("H-<tab>" . company-posframe-quickhelp-toggle)
              ("H-p" . company-posframe-quickhelp-scroll-up)
              ("H-n" . company-posframe-quickhelp-scroll-down)
              )
  )
;; (use-package ivy-posframe
;;   :delight
;;   :defer t
;;   :hook ((ivy-mode swiper-mode counsel-mode) . ivy-posframe-mode)
;;   :custom-face
;;   (ivy-posframe ((t (:background "gray10" :extend t)))) 
;;   :init
;;   (setq ivy-posframe-display-functions-alist
;;         '(
;;           (swiper          . ivy-display-function-fallback)
;;           ;; (complete-symbol . ivy-posframe-display-at-point)
;;           (counsel-M-x     . ivy-posframe-display-at-point)
;;           (t               . ivy-posframe-display-at-point)))
  
;;   ;; Different command can use different display function.
;;   (setq ivy-posframe-height-alist '((swiper . 10)
;;                                     (t      . 20)))
;;   (setq ivy-posframe-parameters
;;         '((left-fringe . 10)
;;           (right-fringe . 10)))
;;   )
#+end_src

*** projectile
#+begin_src emacs-lisp :lexical t :tangle no

(use-package projectile
  :delight '(:eval (concat " [" (projectile-project-name) "]"))
  :config
  (projectile-mode t)
  )

#+end_src

*** python

***** how to open python [4/8]
- [X] first need to start kernel (how to know which one to start)
- [X] that same kernel needs to start eglot (must get sent to eglot in parallel)
- [X] need to name that kernel the file name (so that kernels are unique)
- [X] need to associate the kernel with the buffer using associate-buffer
- [ ] Use tabbar and window managers to fix the output. (tabbar broken?)
- [ ] poppler still finicky, need to fix it
- [ ] capture output and organize somehow. Copy buffer to another?
- [ ] maybe need to do a jupyter kernel server? That way I can work on comp. Issue is how to jupytext the files?
  
***** TODO [1/3]
- [ ] how to handle errors i.e. stop running cells and show the correct linum of the whole doc not of the cell
- [ ] need to go through all cells and clear all
- [X] add in cells above, cells below
  
***** things I want to keep in mind
 I like this
(setq jupyter-repl-echo-eval-p nil) is there a mini of this where just the output is sent to the repl cells?

**** code-cells
#+begin_src emacs-lisp :lexical t

(use-package code-cells
  :defer t
  :config
  (setcdr code-cells-mode-map nil)
  (defun seth-code-cells/add-time-stamp-after-execute (&optional var)
    (interactive)
    (unless var (setq var nil))
    (unless (boundp 'seth-code-cells/jupyter-execution-count) (setq-local seth-code-cells/jupyter-execution-count 1))
    (let (
          (bounds (code-cells--bounds 1))
          )
      (save-excursion
        (goto-char (car bounds))
        (kill-line)
        (insert (concat
                 "# %% "
                 (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time))
                 " ["
                 (int-to-string seth-code-cells/jupyter-execution-count)
                 "]"
                 ))
        (apply 'code-cells-eval (code-cells--bounds 1))
        (setq-local seth-code-cells/jupyter-execution-count (1+ seth-code-cells/jupyter-execution-count))
        )
      (if var
          (code-cells-forward-cell 1)
        )
      )      
    )

  (defun seth-code-cells/clear-timestamps ()
    (interactive)
    (let (
          (bounds (code-cells--bounds 1))
          )
      (save-excursion
        (goto-char (car bounds))
        (kill-line)
        (insert "# %%")
        )
      )
    )

  (defun seth-code-cells/restart-jupyter-execution-count (&rest arg)
    (setq-local seth-code-cells/jupyter-execution-count 1)
    )

  (defun seth-code-cells/add-cell (&rest arg)
    (interactive)
    (let (
          (bounds (code-cells--bounds 1))   
          )
      (cond
       (arg 
        (goto-char (car bounds))
        (open-line 2)
        (insert "# %%")
        (open-line 1)
        (next-line 1)
        (print "in arg")
        )
       (t
        (goto-char (car (cdr bounds)))
        (open-line 1)
        (next-line 1)
        (insert "# %%")
        (open-line 3)
        (next-line 1)
        (print "not in arg"))
       )
      ))

  (defun seth-code-cells/clear-all-results ()
    "Clear all results in the buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (when (looking-at "# %%")
        (kill-line)
        (insert "# %%")
        )
      (while (code-cells-forward-cell 1)
          (kill-line)
          (insert "# %%")
        ))
    )

  ;; add below to keep track of what has been run
  (add-hook 'python-mode-hook (lambda ()
                                (setq-local seth-code-cells/jupyter-execution-count 1)))
  (advice-add 'jupyter-repl-restart-kernel :before #'seth-code-cells/restart-jupyter-execution-count)
  (advice-add 'jupyter-run-repl :before #'seth-code-cells/restart-jupyter-execution-count)

  ;; (defun start-python (env))

  :hook (python-mode . code-cells-mode-maybe)
  :bind (
         :map code-cells-mode-map
         ("C-c C-c" . seth-code-cells/add-time-stamp-after-execute)
         ("C-<return>" . (lambda() (interactive) (seth-code-cells/add-time-stamp-after-execute 1)))
         ("C-c c a" . (lambda() (interactive) (seth-code-cells/add-cell 1))) ;; add above
         ("C-c c b" . (lambda() (interactive) (seth-code-cells/add-cell ))) ;; add below
         ("M-p" . code-cells-backward-cell)
         ("M-n" . code-cells-forward-cell)
         ("C-c c ;" . code-cells-comment-or-uncomment)
         ("C-c c h" . code-cells-mark-cell)
         ("C-c c o" . seth-code-cells/clear-timestamps)
         )
  )
#+end_src

**** eglot
#+begin_src emacs-lisp :lexical t
(use-package eglot
  :defer t
  :init
  (setq-default eglot-workspace-configuration
                '(:pylsp (:plugins (
                                    :pylint (:enabled :json-false)
                                    :autopep8 (:enabled :json-false)
                                    ;; :yapf (:enabled :json-false)
                                    :mccabe (:enabled :json-false)
                                    ))
                         ))
  (setq eldoc-echo-area-use-multiline-p nil)
  :bind (
         ("C-c p" . start-eglot-python)
         )
  :config
  (global-flycheck-eglot-mode 1)
  (defun start-eglot-python ()
    (interactive)
    (let* (
           (spec (jupyter-completing-read-kernelspec nil nil))
           (env (jupyter-kernelspec-name spec))
           (contact (concat
                     (shell-command-to-string "conda info --base | tr -d '\n'")
                     (concat "/envs/" env "/bin/pylsp")
                     )
                    )
           (managed-modes (list major-mode))
           (project (eglot--current-project))
           (class eglot-lsp-server)
           (language-ids (list "python"))
           )
      (apply 'eglot (list managed-modes project class (list contact) language-ids))
      (jupyter-run-repl env buffer-file-name t 'jupyter-repl-client)
      )
    )  
  )

(use-package jsonrpc
  :defer t
  )

(use-package flycheck-eglot
  :defer t
  )

#+end_src

**** Jupyter
#+begin_src emacs-lisp :lexical t
(use-package jupyter
  :defer t
  :custom
  (jupyter-eval-use-overlays t)
  :config
  (defvaralias 'org-babel-jupyter-resource-directory 'jupyter-org-resource-directory)
  (setq org-babel-jupyter-resource-directory "./plots/")
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (julia . t)
     (python . t)
     (jupyter . t)))
  )

(use-package zmq
  :defer t)
#+end_src

**** python
#+begin_src emacs-lisp :lexical t

(use-feature python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)
  :bind (
         :map python-mode-map
              ("H-<left>" . python-indent-shift-left)
              ("H-<right>" . python-indent-shift-right)
         )
  )
#+end_src

**** yapify
#+begin_src emacs-lisp :lexical t
(use-package yapfify
  :defer t
  :hook (python-mode . yapf-mode))
;; (add-hook 'python-mode-hook 'yapf-mode)
#+end_src

*** Scimax 
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature ox-clip
  :ensure (ox-clip
           :type git
           :host github
           :repo "jkitchin/ox-clip"
           :local-repo "ox-clip"
           :files (:defaults)
           )
  :defer t
  )

(use-package scimax-jupyter
  :ensure (scimax
           :type git
           :host github
           :repo "jkitchin/scimax"
           :local-repo "scimax"
           :files (:defaults (:exclude "*.org" "scimax.el" "bootstrap.el" "init.el" "packages.el" "scimax-evil.el" "debug-windows.el"))
           )
  :config
  (defconst scimax-dir (file-name-directory "./elpaca/builds/scimax/"))  
  (add-to-list 'load-path scimax-dir)
  ;; ** helper functions
  (defun /jupyter-clean-async--results () 
    "cleans drawer results for async jupyter code blocks"
    (search-forward "#+begin_example")
    (beginning-of-line)
    (delete-region (pos-bol) (pos-bol 2)) 
    (search-forward "#+end_example")
    (beginning-of-line)
    (delete-region (pos-bol) (pos-bol 2))
    )

  (defun /jupyter-clean-async-ansi--results ()
    "cleans drawer results for async jupyter code blocks"
    (let* ((r (org-babel-where-is-src-block-result))
	       (result (when r
		             (save-excursion
		               (goto-char r)
		               (org-element-context)))))
      (when result
        (let* ((sp (org-element-property :begin result))
               (ep (org-element-property :end result)))
          (replace-string-in-region "[43m" "[45m" sp ep ) ;; replace yellow highlights
          (replace-string-in-region ";43m" ";45m" sp ep )
          (replace-string-in-region "[34m" "[33m" sp ep ) ;; replace blue text
          (replace-string-in-region ";34m" ";33m" sp ep )
          t
          ))
      t)
    (scimax-jupyter-ansi)
    (/jupyter-clean-async--results)
    )

  (defun seth-interrupt-kernel ()
    "Clear all results in the buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      ;; (while (org-babel-next-src-block)
      ;;   (forward-line 1)
      ;;   ;; (jupyter-org-interrupt-kernel)
      ;;   )
      (let* ((num 0))
        (while (< num 5)
          (org-babel-next-src-block)
          (forward-line 1)
          (jupyter-org-interrupt-kernel)
          (setq num (+1 num))))
      )
    )
  ;; *** remove result if empty
  (with-eval-after-load 'jupyter-client
    (defun /jupyter-remove-empty-async-results (args)
      "remove results block if the results are empty"
      (let*
          ((req (nth 1 args))
           (msg (nth 2 args))
           (is-org-request (eq (type-of req) 'jupyter-org-request)))
        (when is-org-request
          (jupyter-with-message-content msg (status payload)
            (when (and (jupyter-org-request-async-p req)
                       (equal status "ok")
                       (not (jupyter-org-request-id-cleared-p req)))
              (jupyter-org--clear-request-id req)
              (org-with-point-at (jupyter-org-request-marker req)
                (org-babel-remove-result)))))
        args))
    (unless (advice-member-p #'/jupyter-remove-empty-async-results 'jupyter-handle-execute-reply)
      (advice-add 'jupyter-handle-execute-reply :filter-args #'/jupyter-remove-empty-async-results)))

  ;; *** remove example and clean up errors
  (with-eval-after-load 'jupyter-client
    (defun /jupyter-ansi-async-results (args)
      "Translate the ansi key code in results with errors"
      (let*
          ((req (nth 1 args))
           (msg (nth 2 args))
           (is-org-request (eq (type-of req) 'jupyter-org-request)))
        (when is-org-request
          (jupyter-with-message-content msg (status payload)
            (when (and (jupyter-org-request-async-p req)
                       (not (equal status "ok")))
              (org-with-point-at (jupyter-org-request-marker req)
                (/jupyter-clean-async-ansi--results)
                )
              (org-with-point-at (jupyter-org-request-marker req)
                (when (not (search-forward "KeyboardInterrupt" nil t))
                  (seth-interrupt-kernel)))
              )))
        args))
    (unless (advice-member-p #'/jupyter-ansi-async-results 'jupyter-handle-execute-reply)
      (advice-add 'jupyter-handle-execute-reply :filter-args #'/jupyter-ansi-async-results)))

  ;; *** remove example src block from result
  (with-eval-after-load 'jupyter-client
    (defun /jupyter-clean-async-results (args)
      "calls the cleaning of async results in jupyter blocks"
      (let*
          ((req (nth 1 args))
           (msg (nth 2 args))
           (is-org-request (eq (type-of req) 'jupyter-org-request)))
        (when is-org-request
          (jupyter-with-message-content msg (status payload)
            (when (and (jupyter-org-request-async-p req)
                       (equal status "ok")
                       (jupyter-org-request-id-cleared-p req))
              (org-with-point-at (jupyter-org-request-marker req)
                (/jupyter-clean-async--results)
                ))))
        args))

    (unless (advice-member-p #'/jupyter-clean-async-results 'jupyter-handle-execute-reply)
      (advice-add 'jupyter-handle-execute-reply :filter-args #'/jupyter-clean-async-results)))

  ;; * Numbered lines in code blocks
  (defvar number-line-overlays '()
    "List of overlays for line numbers.")

  (make-variable-buffer-local 'number-line-overlays)

  (defun number-line-src-block ()
    "Add line numbers to an org src-block."
    (interactive)
    (save-excursion
      (let* ((src-block (org-element-context))
             (nlines (- (length
                         (s-split
                          "\n"
                          (org-element-property :value src-block)))
                        1)))
        ;; clear any existing overlays
        (when number-line-overlays
	      (mapc 'delete-overlay
	            number-line-overlays)
	      (setq number-line-overlays '()))

        (goto-char (org-element-property :begin src-block))
        ;; the beginning may be header, so we move forward to get the #+BEGIN
        ;; line. Then jump one more to get in the code block
        (while (not (looking-at "#\\+BEGIN"))
	      (forward-line))
        (forward-line)
        (cl-loop for i from 1 to nlines
                 do
                 (beginning-of-line)
                 (let (ov)
		           (setq ov (make-overlay (point)(point)))
		           (overlay-put
		            ov
		            'before-string (propertize
				                    (format "%03s: " (number-to-string i))
				                    'font-lock-face '(:foreground "WhiteSmoke" :background "gray10")
				                    'local-map (let ((map (make-sparse-keymap)))
					                             (define-key map [mouse-1]
						                                     (lambda ()
						                                       (interactive)
						                                       (mapc 'delete-overlay
							                                         number-line-overlays)
						                                       (setq number-line-overlays '())))
					                             map)))
		           (overlay-put ov 'mouse-face 'highlight)
		           (overlay-put ov 'help-echo "Click to remove")
		           (overlay-put ov 'local-map (let ((map (make-sparse-keymap)))
					                            (define-key map [mouse-1]
						                                    (lambda ()
						                                      (interactive)
						                                      (mapc 'delete-overlay
							                                        number-line-overlays)
						                                      (setq number-line-overlays '())))
					                            map))
		           (add-to-list 'number-line-overlays ov))
                 (forward-line))))
    (add-hook 'post-command-hook 'number-line-src-block nil 'local)
    )

  (add-hook 'jupyter-repl-mode-hook 'company-mode)
  (add-hook 'jupyter-repl-mode-hook 'smartparens-mode)
  (add-hook 'jupyter-repl-mode-hook ;; org mode
            '(lambda ()
               (local-set-key (kbd "H-h h") 'scimax-jupyter-org-hydra/body)
               ))

  (pretty-hydra-define scimax-jupyter-org-hydra (:color blue :hint nil)
    ("Execute"
     (
      ("<return>" nil "quit" :color red)
      ("C-c C-c" org-ctrl-c-ctrl-c "current" :color red)
      ("C-<return>" jupyter-org-execute-and-next-block "current and next" :color red)
      ("H-<return>" (progn (org-ctrl-c-ctrl-c) (scimax-ob-insert-src-block t)) "current and new")
      ("S-C-<return>" jupyter-org-execute-to-point "Execute to point")
      ("S-M-<return>" jupyter-org-execute-subtree "Execute Subtree"))

     "Navigate"
     (("p" org-babel-previous-src-block "previous" :color red)
      ;; ("P" jupyter-org-previous-busy-src-block "previous busy")
      ("n" org-babel-next-src-block  "next" :color red)
      ;; ("N" jupyter-org-next-busy-src-block "next busy" :color red)
      ("g" jupyter-org-jump-to-visible-block "jump to visible src")
      ("G" jupyter-org-jump-to-block "jump to src block")
      ("e" scimax-jupyter-jump-to-error "Jump to error"))

     "Edit"
     (("<up>" jupyter-org-move-src-block "move up" :color red)
      ("<down>" (jupyter-org-move-src-block t) "move down" :color red)
      ("x" jupyter-org-kill-block-and-results "kill block")
      ("c" jupyter-org-copy-block-and-results "copy block")
      ("o" (jupyter-org-clone-block t) "clone")
      ("m" jupyter-org-merge-blocks "merge")
      ("s" jupyter-org-split-src-block "split")
      ("a" (jupyter-org-insert-src-block nil current-prefix-arg) "insert above")
      ("b" (jupyter-org-insert-src-block t current-prefix-arg) "insert below")
      ("l" org-babel-remove-result "clear result")
      ("L" seth-clear-all-results "clear all results")
      ("h" jupyter-org-edit-header "edit header"))

     "Misc"
     (("i" jupyter-org-inspect-src-block "inspect")
      ("<tab>" completion-at-point "Complete")
      
      ("O" scimax-ob/body "scimax-ob")
      ("E" ox-ipynb-export-to-ipynb-no-results-file-and-open "Export to ipynb no results")
      ("q" nil "quit"))
     
     "Kernel"
     (("s" org-babel-jupyter-scratch-buffer "scratch")
      ("z" org-babel-switch-to-session "REPL")
      ("u" jupyter-org-interrupt-kernel "interrupt")
      ("r" (progn (setq-local seth-jupyter-execution-count 1)
                  (jupyter-org-with-src-block-client
	               (jupyter-repl-restart-kernel))) "restart")
      ("k" (progn (setq-local seth-jupyter-execution-count 1) (scimax-jupyter-org-kill-kernel)) "kill"))))

  :bind (
         ;; ("H-h w" . words-hydra/body)
         :map jupyter-org-interaction-mode-map
         ("H-h j" . scimax-jupyter-org-hydra/body)
         ("H-<left>" . python-indent-shift-left)
         ("H-<right>" . python-indent-shift-right)
         ("C-<return>" . jupyter-org-execute-and-next-block)
         ("s-g" . jupyter-org-jump-to-visible-block)              
         ("s-e" . scimax-jupyter-jump-to-error)
         ("s-<up>" . jupyter-org-move-src-block)
         ("s-<down>" . (lambda () (interactive) (jupyter-org-move-src-block t)))
         ("s-x" . jupyter-org-kill-block-and-results)
         ("s-c" . jupyter-org-copy-block-and-results)
         ("s-o" . (lambda () (interactive) (jupyter-org-clone-block t)))
         ("s-m" . jupyter-org-merge-blocks)
         ("s-s" . jupyter-org-split-src-block)
         ("s-a" . jupyter-org-insert-src-block)
         ("s-b" . (lambda () (interactive) (jupyter-org-insert-src-block t)))
         ("s-i" . jupyter-org-inspect-src-block)
         ("s-u" . jupyter-org-interrupt-kernel)
         ("s-k" . (lambda () (interactive) (progn (setq-local seth-jupyter-execution-count 1)
                                                  (scimax-jupyter-org-kill-kernel))))
         ("s-r" . (lambda () (interactive) (progn (setq-local seth-jupyter-execution-count 1)
                                                  (jupyter-org-with-src-block-client
                                                   (jupyter-repl-restart-kernel))))) 
         )
  ) 

#+end_src

*** sideline mode
#+begin_src emacs-lisp :lexical t
(use-package sideline
  :delight
  :defer t
  :hook (
         (flycheck-mode . sideline-mode)  
         (flymake-mode  . sideline-mode)
         )

  :init
  (setq sideline-backends-left-skip-current-line nil   ; don't display on current line (left)
        sideline-backends-right-skip-current-line nil  ; don't display on current line (right)
        sideline-order-left 'down                    ; or 'up
        sideline-order-right 'up                     ; or 'down
        sideline-format-left "%s"                 ; format for left aligment
        sideline-format-right "%s"                ; format for right aligment
        sideline-priority 100                        ; overlays' priority
        sideline-display-backend-name t)             ; display the backend name
  (setq sideline-backends-right '(sideline-flycheck)
        )
  
  )

(use-package sideline-flycheck
  :defer t
  :hook (flycheck-mode . sideline-flycheck-setup))


#+end_src

*** smart-mode-line
#+begin_src emacs-lisp :lexical t :tangle no

(use-package smart-mode-line
  :delight
  :init
  (setq sml/name-width 50
        sml/mode-width 50)
  (setq sml/theme 'respectful)
  :config
  (sml/setup)
  )
  
#+end_src

*** smartparens

#+begin_src emacs-lisp :lexical t

(use-package smartparens
  :delight
  :config
  (require 'smartparens-config)
  (smartparens-global-mode t)
  :bind* (
         ("M-<up>"  . sp-beginning-of-sexp)
         ("M-<down>"  . sp-end-of-sexp)
         ("C-<right>"  . sp-forward-slurp-sexp)
         ("M-<right>"  . sp-forward-barf-sexp)
         ("C-<left>"   . sp-backward-slurp-sexp)
         ("M-<left>"   . sp-backward-barf-sexp)
         ("C-M-k"  . sp-kill-sexp)
         ("C-k"    . sp-kill-hybrid-sexp)
         ("M-k"    . sp-backward-kill-sexp)
         ("C-M-w"  . sp-copy-sexp)
         ("M-s s"  . sp-split-sexp)
         ("M-s j"  . sp-join-sexp)
         ("M-]"  . sp-backward-unwrap-sexp)
         ("M-["  . sp-unwrap-sexp)
         ("C-x C-t"  . sp-transpose-hybrid-sexp)
         )
  :demand t
  )

#+end_src

*** smex
#+begin_src emacs-lisp :lexical t
;; keep recent commands available in M-x
(use-package smex)
  
#+end_src

*** Swiper
#+begin_src emacs-lisp :lexical t
(use-package swiper
  :config
  (defadvice swiper (before dotemacs activate)
    (setq gc-cons-threshold most-positive-fixnum))
  (defadvice swiper-all (before dotemacs activate)
    (setq gc-cons-threshold most-positive-fixnum))
  :defer t
  :delight
  :bind* (
         ("C-s" . swiper)
         ("H-s" . swiper-all)
         )
  )

#+end_src

*** tabbar

#+begin_src emacs-lisp :lexical t :tangle no
(use-package tabbar
  :defer t
  :bind* (
          ("M-S-<up>" . tabbar-press-home)
          ("M-S-<left>" . tabbar-backward-tab)
          ("M-S-<right>" . tabbar-forward-tab)
          ("M-S-<down>" . tabbar-local-mode)
          ("C-S-<left>" . tabbar-move-group-backward)
          ("C-S-<right>" . tabbar-move-group-forward)
          )

  :config
  (tabbar-mode t)
  (defun tabbar-buffer-groups ()
    "Return the list of group names the current buffer belongs to.
       This function is a custom function for tabbar-mode's tabbar-buffer-groups.
       This function group all buffers into 3 groups:
       Those Dired, those user buffer, and those emacs buffer.
       Emacs buffer are those starting with “*”."
    (list
     (cond
      ((eq major-mode 'dired-mode)
       "Dired"
       )
      ((eq major-mode 'jupyter-repl-mode)
       "Kernels"
       )
      ((eq major-mode 'js2-mode)
       "js"
       )
      ((eq major-mode 'eshell-mode)
       "Eshell"
       )
      ((eq major-mode 'vterm-mode)
       "Term"
       )
      ((eq major-mode 'go-mode)
       "Go"
       )
      ((eq major-mode 'org-mode)
       "Org"
       )
      ((eq major-mode 'python-mode)
       "Python"
       )
      ((string-equal "*ein:" (substring (buffer-name) 0 5))
       "EIN"
       )
      ((string-equal "*Pyth" (substring (buffer-name) 0 5))
       "Python"
       )
      ((eq major-mode 'php-mode)
       "PHP"
       )
      ((eq major-mode 'csv-mode)
       "CSV"
       )
      ((eq major-mode 'text-mode)
       "TXT"
       )
      ((eq major-mode 'shell-script-mode)
       "Script"
       )
      ((eq major-mode 'sh-mode)
       "Script"
       )
      ((string-equal "*PHP*" (substring (buffer-name) 0 5))
       "PHP"
       )
      ;; ((string-equal "*jupyter-" (substring (buffer-name) 0 9))
      ;;  "Jupyter"
      ;;  )
      ((string-equal "*" (substring (buffer-name) 0 1))
       "Emacs Buffer"
       )
      ((string-equal "magit:" (substring (buffer-name) 0 6))
       "Magit"
       )
      ((eq major-mode 'lispy-mode)
       "Lisp"
       )
      ((eq major-mode 'lisp-mode)
       "Lisp"
       )
      ((eq major-mode 'emacs-lisp-mode)
       "Lisp"
       )
      ((eq major-mode 'image-mode)
       "Images"
       )
      (t
       "Misc"
       )
      )))

  (defun tabbar-move-current-tab-one-place-left ()
    "Move current tab one place left, unless it's already the leftmost."
    (interactive)
    (let* ((bufset (tabbar-current-tabset t))
           (old-bufs (tabbar-tabs bufset))
           (first-buf (car old-bufs))
           (new-bufs (list)))
      (if (string= (buffer-name) (format "%s" (car first-buf)))
          old-bufs                     ; the current tab is the leftmost
        (setq not-yet-this-buf first-buf)
        (setq old-bufs (cdr old-bufs))
        (while (and
                old-bufs
                (not (string= (buffer-name) (format "%s" (car (car old-bufs))))))
          (push not-yet-this-buf new-bufs)
          (setq not-yet-this-buf (car old-bufs))
          (setq old-bufs (cdr old-bufs)))
        (if old-bufs ; if this is false, then the current tab's buffer name is mysteriously missing
            (progn
              (push (car old-bufs) new-bufs) ; this is the tab that was to be moved
              (push not-yet-this-buf new-bufs)
              (setq new-bufs (reverse new-bufs))
              (setq new-bufs (append new-bufs (cdr old-bufs))))
          (error "Error: current buffer's name was not found in Tabbar's buffer list."))
        (set bufset new-bufs)
        (tabbar-set-template bufset nil)
        (tabbar-display-update))))

  (defun tabbar-move-current-tab-one-place-right ()
    "Move current tab one place right, unless it's already the rightmost."
    (interactive)
    (let* ((bufset (tabbar-current-tabset t))
           (old-bufs (tabbar-tabs bufset))
           (first-buf (car old-bufs))
           (new-bufs (list)))
      (while (and
              old-bufs
              (not (string= (buffer-name) (format "%s" (car (car old-bufs))))))
        (push (car old-bufs) new-bufs)
        (setq old-bufs (cdr old-bufs)))
      (if old-bufs ; if this is false, then the current tab's buffer name is mysteriously missing
          (progn
            (setq the-buffer (car old-bufs))
            (setq old-bufs (cdr old-bufs))
            (if old-bufs ; if this is false, then the current tab is the rightmost
                (push (car old-bufs) new-bufs))
            (push the-buffer new-bufs)) ; this is the tab that was to be moved
        (error "Error: current buffer's name was not found in Tabbar's buffer list."))
      (setq new-bufs (reverse new-bufs))
      (setq new-bufs (append new-bufs (cdr old-bufs)))
      (set bufset new-bufs)
      (tabbar-set-template bufset nil)
      (tabbar-display-update)))

  (setq tabbar-buffer-groups-function 'tabbar-buffer-groups)

  (setq tabbar-use-images nil)

  (defun tabbar-move-group-backward ()
    "My version of keeping groups visible."
    (interactive)
    (tabbar-backward-tab)
    (tabbar-press-home)
    )
  (defun tabbar-move-group-forward ()
    "My version of keeping groups visible."
    (interactive)
    (tabbar-forward-tab)
    (tabbar-press-home)
    )

  )
#+end_src

*** tab-line
#+begin_src emacs-lisp :lexical t :tangle yes

(use-feature tab-line
  ;; :defer t
  ;; :bind* (
  ;;         ("M-S-<up>" . tabbar-press-home)
  ;;         ("M-S-<left>" . tabbar-backward-tab)
  ;;         ("M-S-<right>" . tabbar-forward-tab)
  ;;         ("M-S-<down>" . tabbar-local-mode)
  ;;         ("C-S-<left>" . tabbar-move-group-backward)
  ;;         ("C-S-<right>" . tabbar-move-group-forward)
  ;;         )

  :config
  (global-tab-line-mode t)
  ;; Always suppress the tab line separator in both windows and term mode
  (setq tab-line-separator " ")

  (setq tab2-load-dir "~/.emacs.d/themes/")

  ;; Unused: Some simple but readable close icons - use all-the-icons-insert to add a new one
  (setq tab-line-unused-close-icons '( "✖️" " "))

  ;; Override the height on the all the button so they are properly sized on 4k display
  ;; fixed in version 30

  ;;  Current modern style button I'm using
  (setq tab-line-close-button
        (propertize "x"
                    'display '(image :type pmb
                                     :file (format "%s%s" tab2-load-dir "open.pmb")
    		                         :height (0.9 . em)
    		                         :face shadow
                                     :margin (2 . 0)
                                     :ascent center)
                    'keymap tab-line-tab-close-map
                    'mouse-face 'tab-line-close-highlight
                    'help-echo "Click to close tab")
        )

  (setq tab-line-left-button
        (propertize " <"
                    'display '(image :type pmb
                                     :file (format "%s%s" tab2-load-dir "chevron_left_16.pmb")
    		                         :height (1 . em)
                                     :margin (2 . 0)
                                     :ascent center)
                    'keymap tab-line-left-map
                    'mouse-face 'tab-line-highlight
                    'help-echo "Click to scroll left")
        )

  (setq tab-line-right-button
        (propertize "> "
                    'display '(image :type pmb
                                     :file (format "%s%s" tab2-load-dir "chevron_right_16.pmb")
    		                         :height (1 . em)
                                     :margin (2 . 0)
                                     :ascent center)
                    'keymap tab-line-right-map
                    'mouse-face 'tab-line-highlight
                    'help-echo "Click to scroll right")
        )

  ;; simple unicode button for the modified marker
  ;;(defvar tab2-modified-marker "◎")
  (defvar tab2-modified-marker "⏺")

  ;; git modified markers - I'm still looking for a better one to display in terminal mode
  (defvar tab2-git-modified-marker (if window-system "" "◨"))

  ;; Space the tabs out a bit
  (defun tab2-space-tab-name (buffer &optional _buffers)
    (format " %s " (buffer-name buffer)))

  (setq tab-line-tab-name-function #'tab2-space-tab-name)

  ;; only put a close button on selected tabs - set to nil if totally unwanted
  (setq tab-line-close-button-show nil) ;; `selected

  ;; But don't include in treemacs windows, doc-view or imenu-list
  (setq tab-line-exclude-modes '(completion-list-mode treemacs-mode doc-view-mode imenu-list-major-mode ediff-meta-mode ediff-mode flymake-diagnostics-buffer-mode end ))

;;; Structure for tracking the views
  ;; tab2 concept of virtual views is a window configuration + buffer list

  (cl-defstruct tab2-view name buffers wc)

  ;; Maintain a global list of views
  ;; TODO: we don't really need to capture the wc until a swap
  (setq tab2-views (list (make-tab2-view :name "default" :wc (current-window-configuration))))
  ;;(setq tab2-current-view 0)
  (set-frame-parameter nil 'tab-line-sel-view 0)

  ;; Return the current view
  (defun tab2-get-current-view ()
    (let ((pos (frame-parameter nil 'tab-line-sel-view)))
      (nth (or pos 0) tab2-views)))

  ;; Return if the current view is the default view
  (defun tab2-default-view-p ()
    (equal (frame-parameter nul 'tab-line-sel-view)  0))

  ;; Save any state - currently just the window configuration but I expect to add more.
  (defun tab2-save-view-state ()
    (setf (tab2-view-wc (tab2-get-current-view)) (current-window-configuration)))

  ;; Simple low-level accessor. Most callers should use tab2-get-filtered-buffer-list
  (defun tab2-get-buffer-list ()
    (tab2-view-buffers (tab2-get-current-view)))

  ;; Simple setter
  (defun tab2-set-buffer-list (form)
    (setf (tab2-view-buffers (tab2-get-current-view)) form))

  ;; Reorder the current views buffer list to match the LRU order
  ;; in the native buffer-list
  (defun tab2-reorder-buffers-by-usage ()
    (interactive)
    (let* ((current-bufs (seq-filter 'tab2-buffer-filter (buffer-list)))
	       (intersect-tabs (seq-filter (lambda (it) (member it (tab2-get-buffer-list)))
				                       current-bufs)))

      (tab2-set-buffer-list intersect-tabs)))

  ;; Reorder the current views buffer list alphabetically
  (defun tab2-reorder-buffers-by-name ()
    (interactive)
    (let* ((current-tabs (tab2-get-buffer-list))
	       (sorted-tabs (sort current-tabs (lambda (tab1 tab2)
					                         (string< (buffer-name (tab2-get-buffer-from-tab tab1))
					                                  (buffer-name (tab2-get-buffer-from-tab tab2)))))))
      (tab2-set-buffer-list sorted-tabs)))


  ;; Return the view with the given name
  (defun tab2-get-view-by-name (name)
    (seq-find (lambda (it) (equal (tab2-view-name it) name))   tab2-views))

  ;; Create a new view and switch to it.
  (defun tab2-new-view (name)
    (interactive "sNew View name: ")
    (message "Creating view: %s" name)
    (when (tab2-get-view-by-name name)
      (error "View %s already exists" name))
    (setq tab2-views (append tab2-views (list (make-tab2-view :name name))))
    ;; Save the current wc
    (tab2-save-view-state)
    ;; Switch over
    (set-window-parameter nil 'tab2-linesel-view (- (length tab2-views) 1))
    ;;  (setq tab2-current-view (- (length tab2-views) 1))
    ;; Switch to an initial scratch buffer
    (switch-to-buffer "*scratch*")
    (delete-other-windows)
    (force-mode-line-update))

  (defun tab2-prompt-new-view ()
    (interactive)
    (let ((name (tab2-quick-command "New view name:")))
      (when name (tab2-new-view name))))

  (defvar-keymap tab2-new-view-keymap
    "<tab-line> <mouse-1>" 'tab2-prompt-new-view
    "RET" #'tab2-new-view)

  (setq tab2-new-view-button
        (propertize " + "
                    'display '(image :type pmb
                                     :file (format "%s%s" tab2-load-dir "plus_16.pmb")
                                     :height (0.8 . em)
                                     :margin (2 . 0)
                                     :ascent center)
                    'keymap tab2-new-view-keymap
                    'mouse-face 'tab-line-highlight
                    'help-echo "Click to add a view"))

  ;; View enumeration by name.
  (defun tab2-list-views ()
    (interactive)
    (mapcar 'tab2-view-name tab2-views))

  ;; Switch between views
  (defun tab2-switch-view-by-name (name)
    (interactive (list (completing-read "Switch to view: " (tab2-list-views))))
    (let* ((new-view (tab2-get-view-by-name name))
	       (new-view-pos (cl-position new-view tab2-views))
	       (old-view (tab2-get-current-view)))

      (when (not new-view)
        (error (format "No view was found named %s" name)))

      (when (and new-view (not (equal new-view old-view)))
        (progn
	      (message "switch to %s" name)
	      (tab2-save-view-state)
	      (set-frame-parameter nil 'tab-line-sel-view new-view-pos)
	      (when (tab2-view-wc new-view)
	        (set-window-configuration (tab2-view-wc new-view)))))))

  ;; Close a view and revert back to default
  (defun tab2-close-view-by-name (name)
    (interactive (list (completing-read "Close view: " (tab2-list-views))))
    (let* ((closing-view (tab2-get-view-by-name name))
	       (current-view (tab2-get-current-view)))
      (when (not closing-view)
        (error (format "No view was found named %s" name)))

      (when (equal (tab2-view-name closing-view) "default")
        (error (format "You cannot close the default view" name)))

      ;; temptemp
      (message "Closing view %s" name)

      ;; switch to default if current is closing
      (when (equal closing-view current-view)
        (progn
	      (tab2-switch-view-by-name "default")
	      (set-frame-parameter nil 'tab-line-sel-view 0)))

      ;; Finally remove the closing-view from the view list
      (setq tab2-views (remove closing-view tab2-views))
      ))

  ;; Switch to the next view in the list
  (defun tab2-next-view()
    (interactive)
    (let* ((oldpos (or (frame-parameter nil 'tab-line-sel-view) 0))
	       (newpos (mod (+ 1 oldpos) (length tab2-views)))
	       (new-view-name (tab2-view-name (nth newpos tab2-views))))

      ;;    (message "next %s to %s:%s" oldpos newpos  new-view-name)
      (tab2-switch-view-by-name  new-view-name)))

  ;; Switch to the prev view in the list
  (defun tab2-prev-view()
    (interactive)
    (let* ((oldpos (or (frame-parameter nil 'tab-line-sel-view) 0))
	       (newpos (mod (- oldpos 1) (length tab2-views)))
	       (new-view-name (tab2-view-name (nth newpos tab2-views))))

      ;;    (message "prev %s to %s:%s" oldpos newpos new-view-name)
      (tab2-switch-view-by-name  new-view-name)))

  ;; categorize a buffer's mode
  (defun tab2-buffer-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string
      major-mode))

  (defvar tab2-white-list-modes
    '(text-mode lisp-interaction-mode messages-buffer-mode)
    "List of modes that will be tracked even if the buffer is not a file")

  (defvar tab2-white-list-buffer-names
    '()
    "List of buffer names that will be tracked even if the buffer is not a file")

  ;; Filter which buffers we'll track in the tabs
  (defun tab2-buffer-filter (buffer)
    (or (buffer-file-name buffer)
        (member (tab2-buffer-mode buffer) tab2-white-list-modes)
        (member (buffer-name buffer) tab2-white-list-buffer-names)))

  ;; Function that returns the current buffer-list.
  ;; This filters out all special buffers and leaves only files and whitelisted buffers by mode
  ;; Adds on the current buffer its filters and isn't in the list
  (defun tab2-get-filtered-buffer-list ()
    (let* ((current-bufs (seq-filter 'tab2-buffer-filter (buffer-list)))
	       (intersect-tabs (seq-filter (lambda (it) (member it current-bufs)) (tab2-get-buffer-list)))
	       (new-tab (when (and (not (member (current-buffer) (tab2-get-buffer-list)))
			                   (member (current-buffer) current-bufs))
		              (current-buffer))))
      (if new-tab
	      (tab2-set-buffer-list (append intersect-tabs (list new-tab)))
        (tab2-set-buffer-list intersect-tabs))))

  ;; Filter special buffers from tab-line maintaining current order
  (setq tab-line-tabs-function 'tab2-get-filtered-buffer-list)

  ;; tabs may just be a buffer or an alist depending on the mode.
  (defun tab2-get-buffer-from-tab (tab)
    (if (bufferp tab) tab (alist-get 'buffer tab)))

  ;; Custom shift tab right tab2-shift-tab-right (&optional event)
  (defun tab2-shift-tab-right (&optional event)
    "Shift current buffer or selected tab right"
    (interactive (list last-nonmenu-event))
    ;;  (when (tab-line-track-tap event)
    (let* ((posnp (and (listp event)
                       (event-start event)))
           (window (and posnp (posn-window posnp)))
           (tab (tab-line--get-tab-property 'tab (car (posn-string posnp))))
           (buffer (tab2-get-buffer-from-tab tab))
	       (n (seq-position (tab2-get-buffer-list) buffer)))
      (with-selected-window (or window (selected-window))

	    (progn
          (tab2-set-buffer-list
           (append
            (seq-take (tab2-get-buffer-list) n)
            (list (elt (tab2-get-buffer-list) (+ n 1)))
            (list (elt (tab2-get-buffer-list) n))
            (seq-drop (tab2-get-buffer-list) (+ n 2)))))))
    (force-mode-line-update))

  ;; Custom tab shift left
  (defun tab2-shift-tab-left (&optional event)
    "Shift current buffer or selected tab left"
    (interactive (list last-nonmenu-event))
    ;;  (when (tab-line-track-tap event))
    (let* ((posnp (and (listp event)
                       (event-start event)))
           (window (and posnp (posn-window posnp)))
           (tab (tab-line--get-tab-property 'tab (car (posn-string posnp))))
	       (buffer (tab2-get-buffer-from-tab tab))
	       (n (seq-position (tab2-get-buffer-list) buffer)))
      (with-selected-window (or window (selected-window))

        (when
            (> n 0)
          (progn
            (tab2-set-buffer-list
             (append
              (seq-take (tab2-get-buffer-list) (- n 1))
              (list (elt (tab2-get-buffer-list) n))
              (list (elt (tab2-get-buffer-list) (- n 1)))
              (seq-drop (tab2-get-buffer-list) (+ n 1)))))))
      (force-mode-line-update)))

  ;; copy current buffer name to kill ring
  (defun tab2-copy-current-filename-to-clipboard (&optional e)
    (interactive "e" )
    (let* ((posnp (event-start e))
           (tab (get-pos-property 1 'tab (car (posn-string posnp))))
	       (buffer (tab2-get-buffer-from-tab tab)))

      (kill-new (buffer-file-name buffer))))

  ;; Override original definition of tab-line-tab-context-menu
  ;; Bind custom actions into the context menu if we are not in group mode
  (define-advice tab-line-tab-context-menu (:override (&optional event))
    "Pop up the context menu for a tab-line tab."
    (interactive "e")

    (unless (window-parameter nil 'tab-line-groups)
      (let ((menu (make-sparse-keymap (propertize "Context Menu" 'hide t))))
        (define-key-after menu [close]
	      '(menu-item "Close" tab-line-close-tab :help "Close the tab"))
        (define-key-after menu [shiftleft]
	      '(menu-item "Shift Left" tab2-shift-tab-left :help "Shift the tab left"))
        (define-key-after menu [shiftright]
	      '(menu-item "Shift Right" tab2-shift-tab-right :help "Shift the tab right"))
        (define-key-after menu [copypath]
	      '(menu-item "Copy Path" tab2-copy-current-filename-to-clipboard :help "Copy the current tab filename to the clipboard"))
        (define-key-after menu [reorder-lru]
	      '(menu-item "Reorder tabs by usage" tab2-reorder-buffers-by-usage :help "Reorder the tabs based on their usage in the buffer-list"))

        (popup-menu menu))))

  (defun tab2-buffer-in-multiple-viewsp (buffer)
    (let ((count 0))
      (dolist (view tab2-views)
        (when (member buffer (tab2-view-buffers view)) (setq count (+ 1 count))))

      (> count 1)))


  ;; Logic to carefully close a tab. buffer is only killed if its the last one.
  (defun tab2-close-tab (&optional e)
    (let* ((posnp (event-start e))
           (window (posn-window posnp))
           (tab (get-pos-property 1 'tab (car (posn-string posnp))))
	       (buffer (tab2-get-buffer-from-tab tab)))

      (if (tab2-buffer-in-multiple-viewsp buffer)
	      ;; The buffer is in other views so only:
	      ;; remove this buffer from the buffer list for this view and switch
	      (let* ((view (tab2-get-current-view))
	             (new-buffers (remove buffer (tab2-view-buffers view))))

	        (setf (tab2-view-buffers view) new-buffers)

	        (if new-buffers (switch-to-buffer (nth 0 new-buffers))
	          (switch-to-buffer "*scratch*")))

        ;; This buffer is only in this view
        (with-selected-window window
	      (let ((tab-list (tab-line-tabs-window-buffers))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (tab-line-tabs-window-buffers) list))
					                      (window-list) nil))))

            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
		          (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
		          (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
	          (progn
                (and (kill-buffer buffer)
		             (unless (cdr tab-list)
                       (ignore-errors (delete-window window))))))))
        )))

  (define-advice tab-line-close-tab (:override (&optional e))
    "Close the selected tab.
If the tab is presented in another window, close the tab by using the `bury-buffer` function.
If the tab is unique to all existing windows, kill the buffer with the `kill-buffer` function.
Lastly, if no tabs are left in the window, it is deleted with the `delete-window` function."
    (interactive "e")

    (let* ((posnp (event-start e))
	       (tab (get-pos-property 1 'tab (car (posn-string posnp))))
	       (buffer (tab2-get-buffer-from-tab tab))
	       (close (unless (bufferp tab) (alist-get 'close tab))))

      ;; User the specified close function if specified or default to tab2-close-tab
      (if (functionp close) (funcall close e) (tab2-close-tab e))
      (force-mode-line-update)))

  ;; todo may need to force update more expansively for multiple windows when split
  (defun tab2-mouse-move-tab (event)
    "Move a tab to a different position on the tab line.
This command should be bound to a drag event.  It moves the tab
at the mouse-down event to the position at mouse-up event."
    (interactive "e")
    (let* ((from-str (posn-string (event-start event)))
           (to-str (posn-string (event-end event)))
	       (from-rowcol (posn-col-row (event-start event)))
	       (to-rowcol (posn-col-row (event-end event)))
	       (from (tab-line--get-tab-property 'tab (car from-str)))
           (to (tab-line--get-tab-property 'tab (car to-str))))

      ;;    (message "move %s p:%s to %s p:%s" from-str (car from-rowcol) to-str (car to-rowcol))

      ;; Only adjust if the two tabs are different
      ;; if going left to right add on the right and vice versa if going right to left
      (unless (or (eq from to) (eq from t) (eq to t))
        (tab2-set-buffer-list
	     (reverse (let (value)
		            (dolist (elt (tab2-get-buffer-list) value)
			          ;; add the element in its new position moving leftwards
			          (if (and (equal elt (tab2-get-buffer-from-tab to)) (> (car from-rowcol) (car to-rowcol)))
			              (setq value (cons (tab2-get-buffer-from-tab from) value)))
			          ;; add all other elements in old position
			          (if (not (equal elt (tab2-get-buffer-from-tab from)))
			              (setq value (cons elt value)))
			          ;; add the element in its new position moving rightwards
			          (if (and (equal elt (tab2-get-buffer-from-tab to)) (>= (car to-rowcol) (car from-rowcol)))
			              (setq value (cons (tab2-get-buffer-from-tab from) value)))
			          ))))
        (force-mode-line-update))))

  ;; Add on our extra key map for the drag event
  (keymap-set tab-line-tab-map   "<tab-line> <drag-mouse-1>"      #'tab2-mouse-move-tab)

  ;; Advice to add on add-new view button in the view view
  (define-advice tab-line-format (:filter-return (format))
    (if (window-parameter nil 'tab-line-views)
        (append format (list tab2-new-view-button))
      format))
  (defmacro my-ignore (form))

  (my-ignore (advice-remove 'tab-line-format nil))

  ;; Convenience wrapper for getting the git state which needs to be done in buffer
  ;; but is  more accurate than vc-state
  (defun tab2-git-state (buffer)
    (with-current-buffer buffer
      (vc-git-state (buffer-file-name buffer))))

  ;; Custom tab-line-name-format function to add on a face for the modified signifier
  ;; so it can be colored or not depending on being selected
  ;; and filter icon to the first tab
  (defun tab2-format-tab (tab tabs)
    "Override for  `tab-line-tab-name-format-function' that adds on a modified buffer face and indicator"
    (let* ((buffer (tab2-get-buffer-from-tab tab))
           (selected-p (if buffer
                           (eq buffer (window-buffer))
                         (cdr (assq 'selected tab))))

           (name (if buffer
                     (funcall tab-line-tab-name-function buffer tabs)
                   (cdr (assq 'name tab))))
           (face (if selected-p
                     ;;                  (if (mode-line-window-selected-p)
                     'tab-line-tab-current
                   ;;                  'tab-line-tab)
                   'tab-line-tab-inactive))
	       (group-view (window-parameter nil 'tab-line-groups)))

      ;; the face funcs expect to get called with whether the tab is a buffer
      ;; so we can't use buffer directly here
      (dolist (fn tab-line-tab-face-functions)
        (progn
	      (setf face (funcall fn tab tabs face (bufferp tab) selected-p))))

      (apply 'propertize
             (concat
	          (propertize (string-replace "%" "%%" name) ;; (bug#57848)
                          'face face
                          'keymap tab-line-tab-map
                          'help-echo (if selected-p "Current tab"
                                       "Click to select tab")
                          ;; Don't turn mouse-1 into mouse-2 (bug#49247)
                          'follow-link 'ignore)

	          ;; Modified marker - TODO - move to custom faces
	          (cond ((and buffer (buffer-modified-p buffer) (buffer-file-name buffer))
		             (if selected-p
		                 (propertize (format "%s " tab2-modified-marker) 'face `(:inherit ,face :foreground "red2" :height .9 :slant normal ))
		               (propertize (format "%s " tab2-modified-marker) 'face `(:inherit ,face :height .9 :slant normal ))))

		            ((and buffer (buffer-file-name buffer)
			              (string= (tab2-git-state buffer) "edited"))
		             (progn
                       ;;		     (message "git modified: %s %s" buffer (vc-state (buffer-file-name buffer)))
		               (if selected-p
			               (propertize (format "%s " tab2-git-modified-marker) 'face `(:inherit ,face :foreground "dark cyan" :height .9 :slant normal ))
		                 (propertize (format "%s " tab2-git-modified-marker) 'face `(:inherit ,face :height .9 :slant normal ))))))

              (let ((close (or (and (or buffer (assq 'close tab))
                                    tab-line-close-button-show
                                    (not (eq tab-line-close-button-show
                                             (if selected-p 'non-selected
                                               'selected)))
                                    tab-line-close-button)
                               "")))

	            (setq close2 (copy-sequence close))
                ;; Don't overwrite the icon face
                (add-face-text-property 0 (length close2) face t close2)
                close2))

             `(
               tab ,tab
               ,@(if selected-p '(selected t))
               mouse-face tab-line-highlight))
      ))


  ;; Group of tab constructors
  (defun tab2-make-group-tab (selected-group groupname)
    (let ((formatted-name   (format " %s " groupname)))
      `(tab
        (name . ,formatted-name)
        (selected . ,(equal selected-group groupname))
        (select . ,(lambda ()
                     (set-window-parameter nil 'tab-line-groups nil)
                     (set-window-parameter nil 'tab-line-group groupname)
                     (set-window-parameter nil 'tab-line-hscroll nil))))))

  (defun tab2-make-view-category-tab (selected-view viewname)
    (let ((formatted-name   (format " %s " viewname)))
      `(tab
        (name . ,formatted-name)
        (selected . ,(equal selected-view viewname))
        (select . ,(lambda ()
                     (set-window-parameter nil 'tab-line-views t)
                     (set-window-parameter nil 'tab-line-hscroll nil))))))

  (defun tab2-make-view-tab (selected-view viewname)
    (let* ((formatted-name (format " %s " viewname))
	       (new-view (tab2-get-view-by-name viewname))
	       (new-view-pos (cl-position new-view tab2-views)))

      (if (equal viewname "default")
	      `(tab
	        (name . ,formatted-name)
	        (selected . ,(equal selected-view viewname))
	        (select . ,(lambda ()
		                 (tab2-switch-view-by-name viewname)
		                 (set-frame-parameter nil 'tab-line-sel-view new-view-pos)
                         (set-window-parameter nil 'tab-line-hscroll nil))))

	    `(tab
	      (name . ,formatted-name)
	      (selected . ,(equal selected-view viewname))
	      (close . ,(lambda (&optional b)
		              (tab2-close-view-by-name viewname)))
	      (select . ,(lambda ()
		               (tab2-switch-view-by-name viewname)
		               (set-frame-parameter nil 'tab-line-sel-view new-view-pos)
                       (set-window-parameter nil 'tab-line-hscroll nil)))))))


  ;; predicate to determine if a buffer is modified and backed by a file
  (defun tab2-buffer-modified-file-p (buffer)
    (and (buffer-file-name buffer) (buffer-modified-p buffer)))

  ;; Return a list of the buffers opened in the current project
  ;; or nil if we're not in a project
  (defun tab2-get-project-buffer-list ()
    (let ((pr (project-current nil)))
      (when pr (project-buffers pr))))

  ;; Filter the list of buffers based on the selected group
  ;; if Files then return all of the file based buffers.
  ;; if Project then return all files in the curent project.
  (defun  tab2-filter-buffers-by-group (buffers curgroup)
    (let ((project-buffers (tab2-get-project-buffer-list)))
      (cond ((not curgroup) buffers)
	        ((equal curgroup "Files")
	         (seq-filter (lambda (b) (buffer-file-name b)) buffers))

	        ((equal curgroup "Project")
	         (seq-filter (lambda (b) (member b project-buffers)) buffers))

	        ((equal curgroup "Modified")
	         (seq-filter (lambda (b) (tab2-buffer-modified-file-p b)) buffers))

	        (t (seq-filter (lambda (b)
			                 (equal (tab-line-tabs-buffer-group-name b) curgroup))
			               buffers)))))

  (defun find-first (fn ls)
    (cond ((null ls) nil)
          ((funcall fn (car ls)) (car ls))
          (t (find-first fn (cdr ls)))))

  ;; Setup the list of tabs to be displayed.
  ;; Note: these will returned in the tab list format
  ;; tab2-format-tab is then responsible for formatting each one i.e faces / close icons etc.
  (defun tab2-get-tabs ()
    "Return a list of tabs that should be displayed in the tab line.
  This version is based on tab-line-tabs-buffers-groups but
  changes first group to an icon and adds on all files"

    (cond
     ;; views view
     ((window-parameter nil 'tab-line-views)
      (let* ((selected-view (tab2-view-name (tab2-get-current-view)))
	         (tabs (mapcar (lambda (view)
			                 (tab2-make-view-tab selected-view (tab2-view-name view)))
			               tab2-views)))
        tabs))

     ;; groups view
     ((window-parameter nil 'tab-line-groups)
      (let* ((buffers (funcall tab-line-tabs-buffer-list-function))
	         (groups (delq nil (mapcar #'car (seq-group-by
					                          (lambda (buffer)
                                                (tab-line-tabs-buffer-group-name
                                                 buffer))
                                              buffers))))
	         (selected-group (window-parameter nil 'tab-line-group))
	         (tabs (mapcar (apply-partially 'tab2-make-group-tab selected-group) groups)))

        ;;insert a Files and Project group
        (append
         (when (project-current nil)
	       (list (tab2-make-group-tab selected-group "Project")))
         (list (tab2-make-group-tab selected-group "Files"))
         ;; Insert a modified group if any files are modified

         (when (find-first 'tab2-buffer-modified-file-p buffers)
	       (list (tab2-make-group-tab selected-group "Modified")))
         tabs
         (list (tab2-make-view-category-tab
	            (tab2-view-name (tab2-get-current-view)) "Views")))))

     ;; default tabs view
     (t (let* (
	           (selected-group (window-parameter nil 'tab-line-group))
	           (all-buffers (funcall tab-line-tabs-buffer-list-function))
	           (buffers (tab2-filter-buffers-by-group all-buffers selected-group))
	           (sorted-buffers (if (functionp tab-line-tabs-buffer-group-sort-function)
				                   (seq-sort tab-line-tabs-buffer-group-sort-function
					                         buffers)
			                     buffers))
	           (tabs (mapcar (lambda (buffer)
			                   `(tab
			                     (name . ,(funcall tab-line-tab-name-function buffer))
			                     (selected . ,(eq buffer (current-buffer)))
			                     (buffer . ,buffer)
			                     (close . tab2-close-tab)))
			                 sorted-buffers)))

          ;;	(message "chk g:%s b:%s" selected-group buffers)
	      tabs))))

  ;; If the current window is in a valid group that is not currently
  ;; set - switch the selected group to match it.
  ;; TODO: make configurable?
  (defun tab2-auto-track-selected-window (&optional _frame)
    (let ((bufgroup (tab-line-tabs-buffer-group-name (current-buffer)))
	      (filep (buffer-file-name (current-buffer)))
	      (valid (tab2-buffer-filter (current-buffer)))
	      (selected-group (window-parameter nil 'tab-line-group)))

      ;;    (message "autotrack: %s %s %s %s" bufgroup filep valid selected-group)

      (when (or (and (not selected-group) valid)
	            (and selected-group
		             valid
		             (not (equal bufgroup selected-group))
		             (not (and filep (equal selected-group "Project") (project-current nil)))
		             (not (and filep (equal selected-group "Files")))))

        (set-window-parameter nil 'tab-line-group bufgroup))))


  ;; Setup the window buffer changes functions to monitor when a window is selected
  ;; Hook that up to the auto-track function
  (setq window-buffer-change-functions (cons 'tab2-auto-track-selected-window window-buffer-change-functions))

  ;; Set the override tab name format function to the one I've defined
  (setopt tab-line-tab-name-format-function 'tab2-format-tab)

  ;; Use custom tab grouping function.
  (setq tab-line-tabs-function 'tab2-get-tabs)

  ;; Set the list-function to use the same one I'm overriding in basic mode
  (setq tab-line-tabs-buffer-list-function 'tab2-get-filtered-buffer-list)

;;; Serialization
  (cl-defstruct tab2-persist-view name buffernames)

  ;; serialize a view
  (defun tab2-convert-to-persist-format (view)
    (let ((name (tab2-view-name view))
	      (buffers (mapcar (lambda (it) (buffer-name it)) (tab2-view-buffers view))))

      (make-tab2-persist-view :name name :buffernames buffers)))

  ;; serialize all views
  (defun tab2-serialize-views ()
    (mapcar (lambda (it) (tab2-convert-to-persist-format it)) tab2-views))

  ;; Deserialize a view
  (defun tab2-convert-from-persist-format (view)
    (let ((name (tab2-persist-view-name view))
	      (buffers (mapcar (lambda (it) (get-buffer it)) (tab2-persist-view-buffernames view))))
      (message "deserialized %s" name)
      (make-tab2-view :name name :buffers buffers)))

  (defun tab2-deserialize-views (views)
    (mapcar (lambda (it) (tab2-convert-from-persist-format it)) views))

  ;; persist bufnames to frame in order for reload
  (defun tab2-save-to-frame ()
    (set-frame-parameter nil 'tab2-views (tab2-serialize-views)))

  ;; process the tab-buffer list in the frame parameters and set up to match
  (defun tab2-rebuild-buffer-list-from-frame-params ()
    (let* ((serialized-views (frame-parameter nil 'tab2-views))
	       (views (tab2-deserialize-views serialized-views)))
      (when views
        (setq tab2-views views))
      (force-mode-line-update)))

  ;; hook the rebuild function to run after read desktop
  (add-hook 'desktop-after-read-hook 'tab2-rebuild-buffer-list-from-frame-params)
  (add-hook 'desktop-save-hook 'tab2-save-to-frame)

  ;;(remove-hook 'desktop-save-hook 'tab2-save-to-frame)

  ;; Add on filter button at the front of the tab list via advice to
  ;; tab-line-format-template
  (defun tab2-add-on-filter-button (tabs)
    (let* ((group-view (window-parameter nil 'tab-line-groups))
	       (viewp (window-parameter nil 'tab-line-views))
	       (icon-file (if viewp "menu_16.pbm" "open.pmb"))
	       (icon-name (format "%s%s" tab2-load-dir icon-file))
           (icon-symbol (if viewp "△" "▼"))
           )
      

      ;; Only prepend the filter button when in buffer-groups mode
      (if (eq  tab-line-tabs-function 'tab2-get-tabs)
	      (cons
	       (propertize icon-symbol
		               'face '(:box (:line-width (0 . 4) :color "#DED8C5" ))
		               ;; todo: change me.
		               'keymap tab-line-button-map
		               'help-echo "Click to change tab filtering"
		               'follow-link 'ignore
		               'display `(image :type pmb
				                        :file ,icon-name
				                        :height (0.8 . em)
				                        :margin (3 . 0)
				                        :relief ,(if group-view -3 3)
				                        :ascent 97
				                        ))
	       tabs)
        tabs)))


  ;; keymap action for when the filter button is selected
  ;; Swaps between group and file mode
  (defun tab2-select-filter-button (&optional _event)
    (interactive "e")
    (let ((group-view (window-parameter nil 'tab-line-groups)))
      (if group-view
	      (progn
	        ;; turn off group and view view
	        (set-window-parameter nil 'tab-line-groups nil)
	        (set-window-parameter nil 'tab-line-views nil)
            (set-window-parameter nil 'tab-line-hscroll nil))
        (progn
	      ;; turn on group view
	      (set-window-parameter nil 'tab-line-groups t)
          (set-window-parameter nil 'tab-line-hscroll nil))))

    (force-mode-line-update))

  (defvar-keymap tab-line-button-map
    :doc "Local keymap for `tab-line-mode' filter button."
    "<tab-line> <mouse-1>" #'tab2-select-filter-button
    "RET" #'tab2-select-filter-button)

  ;; Via advice add on the filter button
  (advice-add 'tab-line-format-template :filter-return 'tab2-add-on-filter-button)

  ;; bunch of code from nicolas rougier adapted to use the header-line
  (defface quick-command-face
    `((t :foreground ,(face-foreground 'default)
         :background ,(face-background 'highlight nil t)
         :height ,(face-attribute 'default :height)
         :box (:line-width (1 . 1)
                           :color ,(face-foreground 'default))
         ))
    "Face for quick command")

  (defface quick-command-prompt-face
    `((t :foreground ,(face-background 'default)
         :background ,(face-foreground 'default)
         :weight ,(face-attribute 'bold :weight nil 'default)
         :box (:line-width (1 . 1)
                           :color ,(face-foreground 'default))
         ))
    "Face for prompt")

  (defface quick-command-cursor-face
    `((t :foreground ,(face-background 'default)
         ;; :background "#d0d0d0"
         :background ,(face-foreground 'default)
         :box (:line-width (1 . 1)
                           :color ,(face-foreground 'default))
         ))
    "Face for cursor")

  (defun tab2-quick-command--update (current-buffer command-buffer)
    "Update header-line with current command"

    (with-current-buffer command-buffer
      (let* ((text (concat (buffer-substring (point-min) (point-max)) " "))
             (point (point))
             (region-beg (if (use-region-p) (- (region-beginning) 1)))
             (region-end (if (use-region-p) (region-end))))
        (add-face-text-property (- point 1) point 'quick-command-cursor-face t text)
        (with-current-buffer current-buffer
          (setq-local header-line-format text))
        (force-mode-line-update))))

  (defun tab2-quick-command (&optional prompt)
    "Read user-input from the header-line using the given PROMPT."

    (interactive)
    (let* ((saved-mode-line header-line-format)
           (command nil)
           (current-buffer (current-buffer))
           (current-window (selected-window))
           (prompt (format " %s " (or prompt "Quick command")))
           (prompt (concat (propertize prompt 'face 'quick-command-prompt-face)
                           " "))
           (command-buffer (get-buffer-create " *quick-command*")))

      ;; To make sure to remove the relative face
      (unwind-protect

          ;; Catch enter or exit key press
          (catch 'break

            (with-current-buffer command-buffer

              ;; Clear previous buffer content
              (let ((inhibit-read-only t))
                (erase-buffer))

              ;; Insert prompt
              (insert (concat (propertize prompt 'intangible t
                                          'cursor-intangible t
                                          'read-only t
                                          'front-sticky nil
                                          'rear-nonsticky t)))
              (tab2-quick-command--update current-buffer command-buffer)
              (cursor-intangible-mode t)

              ;; Main loop where we read key sequences until RET or ESC is pressed
              (while t
                (let* ((message "")
                       (key (key-description (read-key-sequence message))))

                  ;; Command enter
                  (when (string= key "RET")
                    (setq command (buffer-substring (+ (length prompt) 1) (point-max)))
                    (if (> (length command) 0)
                        (throw 'break command)
                      (throw 'break nil)))

                  ;; Command abort
                  (when (and (string= key "C-g")
                             (with-current-buffer command-buffer
                               (not (region-active-p))))
                    (setq command nil)
                    (throw 'break nil))

                  ;; Execute key sequence in command buffer
                  (set-window-buffer current-window command-buffer t)
                  (condition-case error
                      (execute-kbd-macro (kbd key))
                    ((beginning-of-buffer end-of-buffer text-read-only)))
                  ;; Make sure to not go into prompt area
                  (goto-char (max (+ (length prompt) 1) (point)))

                  (set-window-buffer current-window current-buffer t)

                  ;; Update mode line
                  (tab2-quick-command--update current-buffer command-buffer)))))

        ;; Command entered or aborted: restore mode line
        (with-current-buffer current-buffer
          (setq-local header-line-format saved-mode-line)
          (force-mode-line-update))
        (kill-buffer command-buffer)
        (switch-to-buffer current-buffer))))
  
  ;; Set tab-line always on
  ;; (global-tab-line-mode t)
  )

#+end_src

*** tree-sitter
#+begin_src emacs-lisp :lexical t
(use-package tree-sitter
  :delight
  :hook
  ((lua-mode
    python-mode
    emacs-lisp-mode
    csv-mode
    json-mode
    sh-mode
    typescript-mode
    yaml-mode
    ) . siren-tree-sitter-mode-enable)

  :config
  (defun siren-tree-sitter-mode-enable ()
    (tree-sitter-mode t)
    (tree-sitter-hl-mode)
    )
  :defer t)

(use-package tree-sitter-langs
  :defer t
  :after tree-sitter
  )
#+end_src

*** undo
#+begin_src emacs-lisp :lexical t
;; (use-package undo-fu-session
;;   :defer t
;;   :delight
;;   :custom
;;   (undo-fu-session-directory "~/.emacs.d/.saves")
;;   (undo-fu-session-file-limit nil)
;;   :hook
;;   ((prog-mode text-mode) . undo-fu-session-mode)  
;;   )

;; (use-package vundo
;;   :defer t
;;   :delight
;;   :custom
;;   (undo-strong-limit (* 1024 1024 1024)) ; 128 MiB. The change group at which this size is exceeded is discarded itself (along with all older change groups). There is one exception: the very latest change group is only discarded if it exceeds ‘undo-outer-limit’.
;;   (amalgamating-undo-limit 5)
;;   (undo-limit         (* 1024 1024 1024)) ;  96 MiB. The change group at which this size is exceeded is the last one kept.
;;   (gnus-undo-limit 100000)
;;   (undo-outer-limit (* 1024 1024 1024)) ;   1 GiB. If at garbage collection time the undo info for the current command exceeds this limit, Emacs discards the info and displays a warning. This is a last ditch limit to prevent memory overflow.


;;   (vundo-compact-display t)

;;   :bind* ("C-x u" . vundo)
;;   ;; :custom-face
;;   ;; (vundo-highlight ((t (:inherit nil :background "#ff5959" :foreground "white"))))
;;   :custom
;;   (vundo-glyph-alist vundo-unicode-symbols)
;;   )

(use-feature undo-hl
  :ensure (undo-hl
           :type git
           :host github
           :repo "casouri/undo-hl"
           )
  :defer t
  :delight
  :hook
  ((prog-mode text-mode) . undo-hl-mode)
  :custom
  (undo-hl-flash-duration 0.2)
  :custom-face
  (undo-hl-insert ((t (:inherit nil :background "#59c267" :foreground "#1f4023")))) 
  (undo-hl-delete ((t (:inherit nil :background "#ff5959" :foreground "#5e1e1e"))))
  )

(use-package undo-tree
  :delight
  :init
  (defadvice undo-tree-make-history-save-file-name
      (after undo-tree activate)
    (setq ad-return-value (concat ad-return-value ".gz")))
  :custom
  (undo-tree-history-directory-alist `(("." . "~/.emacs.d/.saves")))
  (backup-directory-alist `(("." . "~/.emacs.d/.saves")))
  (backup-by-copying t)
  (delete-old-versions t)
  (kept-new-versions 2)
  (kept-old-versions 6)
  (version-control t)       ; use versioned backups
  (undo-tree-enable-undo-in-region t)
  (undo-strong-limit (* 1024 1024 1024)) 
  (amalgamating-undo-limit 10)
  (undo-limit         (* 1024 1024 1024))
  (gnus-undo-limit 2000)
  (undo-outer-limit (* 1024 1024 1024)) 
  
  :config
  (global-undo-tree-mode)
  )
#+end_src

*** vterm
#+begin_src emacs-lisp :lexical t
(use-package vterm
  :defer t
  ;;; instructions to build vterm
  ;; cd /Users/sethfigueroa/.emacs.d/elpaca/builds/vterm/
  ;; mkdir -p build
  ;; cd build
  ;; cmake ..
  ;; make
  )
(use-package multi-vterm
  :init
  (setq vterm-tramp-shells '(("scp" "/usr/bin/zsh")))
  (setq vterm-shell "/usr/local/bin/zsh")
  :bind (
         ("C-x t" . multi-vterm-project)
         ("C-x M-t" . multi-vterm)
         )
  )

#+end_src

*** yas
#+begin_src emacs-lisp :lexical t

(use-package yasnippet
  :delight yas-minor-mode
  :defer t
  :config
  (yas-global-mode 1)
  )

(use-package yasnippet-snippets  
  )

(use-package ivy-yasnippet
  :bind ("H-," . ivy-yasnippet)
  )
#+end_src

*** zoom
#+begin_src emacs-lisp :lexical t
(use-package zoom
  :delight
  :custom
  (zoom-size '(0.618 . 0.618))
  :defer t
  )
#+end_src

*** neotree
#+begin_src emacs-lisp :lexical t
(use-package neotree
  :delight
  :defer t
  :custom-face
  (neo-dir-link-face ((t (:foreground "#97c8f7" :extend t)))) 
  (dired-marked    ((t (:foreground "#e78c45" :extend t)))) 
  :bind* ("C-x d" . neotree)
  :custom
  (neo-theme 'arrow)
)
#+end_src 
   
